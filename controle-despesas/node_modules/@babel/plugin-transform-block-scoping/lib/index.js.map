<<<<<<< HEAD
{"version":3,"names":["DONE","WeakSet","declare","api","opts","assertVersion","throwIfClosureRequired","tdz","tdzEnabled","Error","name","visitor","VariableDeclaration","path","node","parent","scope","isBlockScoped","convertBlockScopedToVar","_tdzThis","nodes","i","declarations","length","decl","assign","t","assignmentExpression","cloneNode","id","init","buildUndefinedNode","_ignoreBlockScopingTDZ","push","expressionStatement","addHelper","_blockHoist","isCompletionRecord","replaceWithMultiple","Loop","state","ensureBlock","blockScoping","BlockScoping","get","replace","run","replaceWith","CatchClause","ignoreBlock","isLoop","isCatchClause","buildRetCheck","template","statement","isVariableDeclaration","BLOCK_SCOPED_SYMBOL","kind","isInLoop","loopOrFunctionParent","find","isFunction","moveBindingsToParent","isFor","declar","parentScope","getFunctionParent","getProgramParent","Object","keys","getBindingIdentifiers","binding","getOwnBinding","moveBindingTo","isVar","letReferenceFunctionVisitor","traverse","visitors","merge","ReferencedIdentifier","ref","letReferences","localBinding","getBindingIdentifier","closurify","tdzVisitor","letReferenceBlockVisitor","enter","loopDepth","exit","FunctionParent","skip","hoistVarDeclarationsVisitor","self","isForStatement","pushDeclar","sequenceExpression","isForInStatement","isForOfStatement","left","map","expr","loopLabelVisitor","LabeledStatement","innerLabels","label","continuationVisitor","isAssignmentExpression","isUpdateExpression","outsideReferences","reassignments","isReturnStatement","returnStatements","loopNodeTo","isBreakStatement","isContinueStatement","loopVisitor","oldIgnoreLabeless","ignoreLabeless","Function","SwitchCase","oldInSwitchCase","inSwitchCase","loopIgnored","has","loopText","indexOf","hasBreakContinue","set","stringLiteral","hasReturn","objectExpression","objectProperty","identifier","argument","returnStatement","add","inherits","isStrict","isProgram","sourceType","isBlockStatement","directives","some","directive","value","constructor","loopPath","blockPath","block","outsideLetReferences","hasLetReferences","body","loopParent","loopLabel","loop","Map","isLabeledStatement","needsClosure","getLetReferences","checkConstants","updateScopeInfo","wrapClosure","remap","labeledStatement","constBindings","Set","bindings","violation","constantViolations","readOnlyError","throwNode","callExpression","operator","includes","logicalExpression","slice","binaryExpression","unaryExpression","isForXStatement","variableDeclaration","variableDeclarator","generateUidIdentifier","unshift","wrappedInClosure","blockScope","letRefs","key","getBinding","hasOwnBinding","removeBinding","outsideLetRefs","blockPathScope","parentHasBinding","hasGlobal","parentBinding","async","generator","parentPath","rename","buildCodeFrameError","outsideRefs","Array","from","delete","checkLoop","hoistVarDeclarations","args","values","params","isSwitch","type","fn","functionExpression","blockStatement","addContinuations","call","nullLiteral","basePath","hasYield","hasType","FUNCTION_TYPES","yieldExpression","hasAsync","awaitExpression","placeholderPath","index","ret","generateUid","buildHas","callPath","listKey","placeholder","fnPath","loopId","p","insertBefore","unwrapFunctionEnvironment","param","paramName","newParamName","forEach","declarators","names","addDeclarationsFromChild","isClassDeclaration","isFunctionDeclaration","declarPaths","cases","consequents","consequent","j","declars","ifStatement","RETURN"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport type { NodePath, Visitor, Scope, Binding } from \"@babel/traverse\";\nimport { visitor as tdzVisitor } from \"./tdz\";\nimport type { TDZVisitorState } from \"./tdz\";\nimport { traverse, template, types as t } from \"@babel/core\";\nimport type { PluginPass } from \"@babel/core\";\n\nconst DONE = new WeakSet();\n\nexport interface Options {\n  tdz?: boolean;\n  throwIfClosureRequired?: boolean;\n}\n\nexport default declare((api, opts: Options) => {\n  api.assertVersion(7);\n\n  const { throwIfClosureRequired = false, tdz: tdzEnabled = false } = opts;\n  if (typeof throwIfClosureRequired !== \"boolean\") {\n    throw new Error(`.throwIfClosureRequired must be a boolean, or undefined`);\n  }\n  if (typeof tdzEnabled !== \"boolean\") {\n    throw new Error(`.tdz must be a boolean, or undefined`);\n  }\n\n  return {\n    name: \"transform-block-scoping\",\n\n    visitor: {\n      VariableDeclaration(path) {\n        const { node, parent, scope } = path;\n        if (!isBlockScoped(node)) return;\n        convertBlockScopedToVar(path, null, parent, scope, true);\n\n        // @ts-expect-error todo(flow->ts): avoid mutations\n        if (node._tdzThis) {\n          const nodes: t.Node[] = [node];\n\n          for (let i = 0; i < node.declarations.length; i++) {\n            const decl = node.declarations[i];\n            const assign = t.assignmentExpression(\n              \"=\",\n              t.cloneNode(decl.id),\n              decl.init || scope.buildUndefinedNode(),\n            );\n            // @ts-expect-error todo(flow->ts): avoid mutations\n            assign._ignoreBlockScopingTDZ = true;\n            nodes.push(t.expressionStatement(assign));\n            decl.init = this.addHelper(\"temporalUndefined\");\n          }\n\n          // @ts-expect-error todo(flow->ts): avoid mutations\n          node._blockHoist = 2;\n\n          if (path.isCompletionRecord()) {\n            // ensure we don't break completion record semantics by returning\n            // the initialiser of the last declarator\n            nodes.push(t.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          path.replaceWithMultiple(nodes);\n        }\n      },\n\n      Loop(path: NodePath<t.Loop>, state) {\n        const { parent, scope } = path;\n        path.ensureBlock();\n        const blockScoping = new BlockScoping(\n          path,\n          path.get(\"body\"),\n          parent,\n          scope,\n          throwIfClosureRequired,\n          tdzEnabled,\n          state,\n        );\n        const replace = blockScoping.run();\n        if (replace) path.replaceWith(replace);\n      },\n\n      CatchClause(path, state) {\n        const { parent, scope } = path;\n        const blockScoping = new BlockScoping(\n          null,\n          path.get(\"body\"),\n          parent,\n          scope,\n          throwIfClosureRequired,\n          tdzEnabled,\n          state,\n        );\n        blockScoping.run();\n      },\n\n      \"BlockStatement|SwitchStatement|Program\"(\n        path: NodePath<t.BlockStatement | t.SwitchStatement | t.Program>,\n        state,\n      ) {\n        if (!ignoreBlock(path)) {\n          const blockScoping = new BlockScoping(\n            null,\n            path,\n            path.parent,\n            path.scope,\n            throwIfClosureRequired,\n            tdzEnabled,\n            state,\n          );\n          blockScoping.run();\n        }\n      },\n    },\n  };\n});\n\nfunction ignoreBlock(\n  path: NodePath<t.BlockStatement | t.SwitchStatement | t.Program>,\n) {\n  return t.isLoop(path.parent) || t.isCatchClause(path.parent);\n}\n\nconst buildRetCheck = template.statement(`\n  if (typeof RETURN === \"object\") return RETURN.v;\n`);\n\nfunction isBlockScoped(node: t.Node): node is t.VariableDeclaration {\n  if (!t.isVariableDeclaration(node)) return false;\n  if (\n    // @ts-expect-error Fixme: document symbol properties\n    node[t.BLOCK_SCOPED_SYMBOL]\n  ) {\n    return true;\n  }\n\n  if (node.kind !== \"let\" && node.kind !== \"const\" && node.kind !== \"using\") {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * If there is a loop ancestor closer than the closest function, we\n * consider ourselves to be in a loop.\n */\nfunction isInLoop(path: NodePath) {\n  const loopOrFunctionParent = path.find(\n    path => path.isLoop() || path.isFunction(),\n  );\n\n  return loopOrFunctionParent?.isLoop();\n}\n\nfunction convertBlockScopedToVar(\n  path: NodePath<t.VariableDeclaration>,\n  node: t.VariableDeclaration,\n  parent: t.Node,\n  scope: Scope,\n  moveBindingsToParent = false,\n) {\n  if (!node) {\n    node = path.node;\n  }\n\n  // https://github.com/babel/babel/issues/255\n  if (isInLoop(path) && !t.isFor(parent)) {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      declar.init = declar.init || scope.buildUndefinedNode();\n    }\n  }\n\n  // @ts-expect-error todo(flow->ts): avoid mutations\n  node[t.BLOCK_SCOPED_SYMBOL] = true;\n  node.kind = \"var\";\n\n  // Move bindings from current block scope to function scope.\n  if (moveBindingsToParent) {\n    const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n    for (const name of Object.keys(path.getBindingIdentifiers())) {\n      const binding = scope.getOwnBinding(name);\n      if (binding) binding.kind = \"var\";\n      scope.moveBindingTo(name, parentScope);\n    }\n  }\n}\n\nfunction isVar(node: t.Node): node is t.VariableDeclaration {\n  return t.isVariableDeclaration(node, { kind: \"var\" }) && !isBlockScoped(node);\n}\n\ninterface LetReferenceVisitorState extends TDZVisitorState {\n  loopDepth: number;\n  closurify: boolean;\n}\n\nconst letReferenceFunctionVisitor = traverse.visitors.merge([\n  {\n    ReferencedIdentifier(path, state) {\n      const ref = state.letReferences.get(path.node.name);\n\n      // not a part of our scope\n      if (!ref) return;\n\n      // this scope has a variable with the same name so it couldn't belong\n      // to our let scope\n      const localBinding = path.scope.getBindingIdentifier(path.node.name);\n      if (localBinding && localBinding !== ref) return;\n\n      state.closurify = true;\n    },\n  },\n  tdzVisitor,\n] as Visitor<LetReferenceVisitorState>[]);\n\nconst letReferenceBlockVisitor = traverse.visitors.merge([\n  {\n    Loop: {\n      enter(path, state) {\n        state.loopDepth++;\n      },\n      exit(path, state) {\n        state.loopDepth--;\n      },\n    },\n    FunctionParent(path, state) {\n      // References to block-scoped variables only require added closures if it's\n      // possible for the code to run more than once -- otherwise it is safe to\n      // simply rename the variables.\n      if (state.loopDepth > 0) {\n        path.traverse(letReferenceFunctionVisitor, state);\n      } else {\n        path.traverse(tdzVisitor, state);\n      }\n      return path.skip();\n    },\n  },\n  tdzVisitor,\n] as Visitor<LetReferenceVisitorState>[]);\n\nconst hoistVarDeclarationsVisitor: Visitor<BlockScoping> = {\n  enter(path, self) {\n    if (path.isForStatement()) {\n      const { node } = path;\n      if (isVar(node.init)) {\n        const nodes = self.pushDeclar(node.init);\n        if (nodes.length === 1) {\n          node.init = nodes[0];\n        } else {\n          node.init = t.sequenceExpression(nodes);\n        }\n      }\n    } else if (path.isForInStatement() || path.isForOfStatement()) {\n      const { node } = path;\n      if (isVar(node.left)) {\n        self.pushDeclar(node.left);\n        node.left = node.left.declarations[0].id;\n      }\n    } else if (isVar(path.node)) {\n      path.replaceWithMultiple(\n        self.pushDeclar(path.node).map(expr => t.expressionStatement(expr)),\n      );\n    } else if (path.isFunction()) {\n      return path.skip();\n    }\n  },\n};\n\ntype LoopVisitorState = {\n  inSwitchCase: boolean;\n  hasBreakContinue: boolean;\n  innerLabels: string[];\n  hasReturn: boolean;\n  ignoreLabeless: boolean;\n  loopIgnored: WeakSet<t.Node>;\n  isLoop: boolean;\n  map: Map<string, t.BreakStatement | t.ContinueStatement>;\n};\n\nconst loopLabelVisitor: Visitor<LoopVisitorState> = {\n  LabeledStatement({ node }, state) {\n    state.innerLabels.push(node.label.name);\n  },\n};\n\ninterface ContinuationVisitorState {\n  returnStatements: NodePath<t.ReturnStatement>[];\n  reassignments: { [k: string]: boolean | undefined };\n  outsideReferences: Map<string, t.Identifier>;\n}\n\nconst continuationVisitor: Visitor<ContinuationVisitorState> = {\n  enter(path, state) {\n    if (path.isAssignmentExpression() || path.isUpdateExpression()) {\n      for (const name of Object.keys(path.getBindingIdentifiers())) {\n        if (\n          state.outsideReferences.get(name) !==\n          path.scope.getBindingIdentifier(name)\n        ) {\n          continue;\n        }\n        state.reassignments[name] = true;\n      }\n    } else if (path.isReturnStatement()) {\n      state.returnStatements.push(path);\n    }\n  },\n};\n\nfunction loopNodeTo(node: t.Node) {\n  if (t.isBreakStatement(node)) {\n    return \"break\";\n  } else if (t.isContinueStatement(node)) {\n    return \"continue\";\n  }\n}\n\nconst loopVisitor: Visitor<LoopVisitorState> = {\n  Loop(path, state) {\n    const oldIgnoreLabeless = state.ignoreLabeless;\n    state.ignoreLabeless = true;\n    path.traverse(loopVisitor, state);\n    state.ignoreLabeless = oldIgnoreLabeless;\n    path.skip();\n  },\n\n  Function(path) {\n    path.skip();\n  },\n\n  SwitchCase(path, state) {\n    const oldInSwitchCase = state.inSwitchCase;\n    state.inSwitchCase = true;\n    path.traverse(loopVisitor, state);\n    state.inSwitchCase = oldInSwitchCase;\n    path.skip();\n  },\n\n  \"BreakStatement|ContinueStatement|ReturnStatement\"(\n    path: NodePath<t.BreakStatement | t.ContinueStatement | t.ReturnStatement>,\n    state,\n  ) {\n    const { node, scope } = path;\n    if (state.loopIgnored.has(node)) return;\n\n    let replace;\n    let loopText = loopNodeTo(node);\n\n    if (loopText) {\n      if (t.isReturnStatement(node)) {\n        throw new Error(\n          \"Internal error: unexpected return statement with `loopText`\",\n        );\n      }\n      if (node.label) {\n        // we shouldn't be transforming this because it exists somewhere inside\n        if (state.innerLabels.indexOf(node.label.name) >= 0) {\n          return;\n        }\n\n        loopText = `${loopText}|${node.label.name}`;\n      } else {\n        // we shouldn't be transforming these statements because\n        // they don't refer to the actual loop we're scopifying\n        if (state.ignoreLabeless) return;\n\n        // break statements mean something different in this context\n        if (t.isBreakStatement(node) && state.inSwitchCase) return;\n      }\n\n      state.hasBreakContinue = true;\n      state.map.set(loopText, node);\n      replace = t.stringLiteral(loopText);\n    }\n\n    if (t.isReturnStatement(node)) {\n      state.hasReturn = true;\n      replace = t.objectExpression([\n        t.objectProperty(\n          t.identifier(\"v\"),\n          node.argument || scope.buildUndefinedNode(),\n        ),\n      ]);\n    }\n\n    if (replace) {\n      replace = t.returnStatement(replace);\n      state.loopIgnored.add(replace);\n      path.skip();\n      path.replaceWith(t.inherits(replace, node));\n    }\n  },\n};\n\nfunction isStrict(path: NodePath) {\n  return !!path.find(({ node }) => {\n    if (t.isProgram(node)) {\n      if (node.sourceType === \"module\") return true;\n    } else if (!t.isBlockStatement(node)) return false;\n\n    return node.directives.some(\n      directive => directive.value.value === \"use strict\",\n    );\n  });\n}\n\nclass BlockScoping {\n  private parent: t.Node;\n  private state: PluginPass;\n  private scope: Scope;\n  private throwIfClosureRequired: boolean;\n  private tdzEnabled: boolean;\n  private blockPath: NodePath<t.Block | t.SwitchStatement>;\n  private block: t.Block | t.SwitchStatement;\n  private outsideLetReferences: Map<string, t.Identifier>;\n  private hasLetReferences: boolean;\n  private letReferences: Map<string, t.Identifier>;\n  private body: t.Statement[];\n  // todo(flow->ts) add more specific type\n  private loopParent: t.Node;\n  private loopLabel: t.Identifier;\n  private loopPath: NodePath<t.Loop>;\n  private loop: t.Loop;\n  private has: LoopVisitorState;\n  constructor(\n    loopPath: NodePath<t.Loop> | undefined | null,\n    blockPath: NodePath<t.Block | t.SwitchStatement>,\n    parent: t.Node,\n    scope: Scope,\n    throwIfClosureRequired: boolean,\n    tdzEnabled: boolean,\n    state: PluginPass,\n  ) {\n    this.parent = parent;\n    this.scope = scope;\n    this.state = state;\n    this.throwIfClosureRequired = throwIfClosureRequired;\n    this.tdzEnabled = tdzEnabled;\n\n    this.blockPath = blockPath;\n    this.block = blockPath.node;\n\n    this.outsideLetReferences = new Map();\n    this.hasLetReferences = false;\n    this.letReferences = new Map();\n    this.body = [];\n\n    if (loopPath) {\n      this.loopParent = loopPath.parent;\n      this.loopLabel =\n        t.isLabeledStatement(this.loopParent) && this.loopParent.label;\n      this.loopPath = loopPath;\n      this.loop = loopPath.node;\n    }\n  }\n\n  /**\n   * Start the ball rolling.\n   */\n\n  run() {\n    const block = this.block;\n    if (DONE.has(block)) return;\n    DONE.add(block);\n\n    const needsClosure = this.getLetReferences();\n\n    this.checkConstants();\n\n    // this is a block within a `Function/Program` so we can safely leave it be\n    if (t.isFunction(this.parent) || t.isProgram(this.block)) {\n      this.updateScopeInfo();\n      return;\n    }\n\n    // we can skip everything\n    if (!this.hasLetReferences) return;\n\n    if (needsClosure) {\n      this.wrapClosure();\n    } else {\n      this.remap();\n    }\n\n    this.updateScopeInfo(needsClosure);\n\n    if (this.loopLabel && !t.isLabeledStatement(this.loopParent)) {\n      return t.labeledStatement(this.loopLabel, this.loop);\n    }\n  }\n\n  checkConstants() {\n    const constBindings = new Map<string, Binding>();\n\n    // In some cases, there are two different scopes: for example,\n    // for (const x of y) {} has a scope for the loop head and one\n    // for the body.\n    for (const scope of new Set([this.scope, this.blockPath.scope])) {\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        if (binding.kind === \"const\") constBindings.set(name, binding);\n      }\n    }\n\n    const { state } = this;\n\n    for (const [name, binding] of constBindings) {\n      for (const violation of binding.constantViolations) {\n        const readOnlyError = state.addHelper(\"readOnlyError\");\n        const throwNode = t.callExpression(readOnlyError, [\n          t.stringLiteral(name),\n        ]);\n\n        if (violation.isAssignmentExpression()) {\n          const { operator } = violation.node;\n          if (operator === \"=\") {\n            violation.replaceWith(\n              t.sequenceExpression([violation.get(\"right\").node, throwNode]),\n            );\n          } else if ([\"&&=\", \"||=\", \"??=\"].includes(operator)) {\n            violation.replaceWith(\n              t.logicalExpression(\n                // @ts-expect-error todo(flow->ts)\n                operator.slice(0, -1),\n                violation.get(\"left\").node,\n                t.sequenceExpression([violation.get(\"right\").node, throwNode]),\n              ),\n            );\n          } else {\n            violation.replaceWith(\n              t.sequenceExpression([\n                t.binaryExpression(\n                  // @ts-expect-error todo(flow->ts)\n                  operator.slice(0, -1),\n                  violation.get(\"left\").node,\n                  violation.get(\"right\").node,\n                ),\n                throwNode,\n              ]),\n            );\n          }\n        } else if (violation.isUpdateExpression()) {\n          violation.replaceWith(\n            t.sequenceExpression([\n              t.unaryExpression(\"+\", violation.get(\"argument\").node),\n              throwNode,\n            ]),\n          );\n        } else if (violation.isForXStatement()) {\n          // @ts-expect-error TS requires explicit annotation of \"violation\"\n          violation.ensureBlock();\n          violation\n            .get(\"left\")\n            .replaceWith(\n              t.variableDeclaration(\"var\", [\n                t.variableDeclarator(\n                  violation.scope.generateUidIdentifier(name),\n                ),\n              ]),\n            );\n          // @ts-expect-error todo(flow->ts): possible bug \"for(â€¦) switch(){}\"\n          violation.node.body.body.unshift(t.expressionStatement(throwNode));\n        }\n      }\n    }\n  }\n\n  updateScopeInfo(wrappedInClosure?: boolean) {\n    const blockScope = this.blockPath.scope;\n\n    const parentScope =\n      blockScope.getFunctionParent() || blockScope.getProgramParent();\n    const letRefs = this.letReferences;\n\n    for (const key of letRefs.keys()) {\n      const ref = letRefs.get(key);\n      const binding = blockScope.getBinding(ref.name);\n      if (!binding) continue;\n      if (binding.kind === \"let\" || binding.kind === \"const\") {\n        binding.kind = \"var\";\n\n        if (wrappedInClosure) {\n          if (blockScope.hasOwnBinding(ref.name)) {\n            blockScope.removeBinding(ref.name);\n          }\n        } else {\n          blockScope.moveBindingTo(ref.name, parentScope);\n        }\n      }\n    }\n  }\n\n  remap() {\n    const letRefs = this.letReferences;\n    const outsideLetRefs = this.outsideLetReferences;\n    const scope = this.scope;\n    const blockPathScope = this.blockPath.scope;\n\n    // alright, so since we aren't wrapping this block in a closure\n    // we have to check if any of our let variables collide with\n    // those in upper scopes and then if they do, generate a uid\n    // for them and replace all references with it\n\n    for (const key of letRefs.keys()) {\n      // just an Identifier node we collected in `getLetReferences`\n      // this is the defining identifier of a declaration\n      const ref = letRefs.get(key);\n\n      // todo: could skip this if the colliding binding is in another function\n      if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {\n        const binding = scope.getOwnBinding(key);\n        if (binding) {\n          const parentBinding = scope.parent.getOwnBinding(key);\n          if (\n            binding.kind === \"hoisted\" &&\n            // @ts-expect-error todo(flow->ts)\n            !binding.path.node.async &&\n            // @ts-expect-error todo(flow->ts)\n            !binding.path.node.generator &&\n            (!parentBinding || isVar(parentBinding.path.parent)) &&\n            !isStrict(binding.path.parentPath)\n          ) {\n            continue;\n          }\n          // The same identifier might have been bound separately in the block scope and\n          // the enclosing scope (e.g. loop or catch statement), so we should handle both\n          // individually\n          scope.rename(ref.name);\n        }\n\n        if (blockPathScope.hasOwnBinding(key)) {\n          blockPathScope.rename(ref.name);\n        }\n      }\n    }\n\n    for (const key of outsideLetRefs.keys()) {\n      const ref = letRefs.get(key);\n      // check for collisions with a for loop's init variable and the enclosing scope's bindings\n      // https://github.com/babel/babel/issues/8498\n      if (isInLoop(this.blockPath) && blockPathScope.hasOwnBinding(key)) {\n        blockPathScope.rename(ref.name);\n      }\n    }\n  }\n\n  wrapClosure() {\n    if (this.throwIfClosureRequired) {\n      throw this.blockPath.buildCodeFrameError(\n        \"Compiling let/const in this block would add a closure \" +\n          \"(throwIfClosureRequired).\",\n      );\n    }\n    const block = this.block;\n\n    const outsideRefs = this.outsideLetReferences;\n\n    // remap loop heads with colliding variables\n    if (this.loop) {\n      // nb: clone outsideRefs keys since the map is modified within the loop\n      for (const name of Array.from(outsideRefs.keys())) {\n        const id = outsideRefs.get(name);\n\n        if (\n          this.scope.hasGlobal(id.name) ||\n          this.scope.parentHasBinding(id.name)\n        ) {\n          outsideRefs.delete(id.name);\n          this.letReferences.delete(id.name);\n\n          this.scope.rename(id.name);\n\n          this.letReferences.set(id.name, id);\n          outsideRefs.set(id.name, id);\n        }\n      }\n    }\n\n    // if we're inside of a for loop then we search to see if there are any\n    // `break`s, `continue`s, `return`s etc\n    this.has = this.checkLoop();\n\n    // hoist let references to retain scope\n    this.hoistVarDeclarations();\n\n    // turn outsideLetReferences into an array\n    const args = Array.from(outsideRefs.values(), node => t.cloneNode(node));\n    const params = args.map(id => t.cloneNode(id));\n\n    const isSwitch = block.type === \"SwitchStatement\";\n\n    // build the closure that we're going to wrap the block with, possible wrapping switch(){}\n    const fn = t.functionExpression(\n      null,\n      params,\n      t.blockStatement(isSwitch ? [block] : block.body),\n    ) as t.FunctionExpression & { params: t.Identifier[] };\n\n    // continuation\n    this.addContinuations(fn);\n\n    let call: t.CallExpression | t.YieldExpression | t.AwaitExpression =\n      t.callExpression(t.nullLiteral(), args);\n    let basePath = \".callee\";\n\n    // handle generators\n    const hasYield = traverse.hasType(\n      fn.body,\n      \"YieldExpression\",\n      t.FUNCTION_TYPES,\n    );\n    if (hasYield) {\n      fn.generator = true;\n      call = t.yieldExpression(call, true);\n      basePath = \".argument\" + basePath;\n    }\n\n    // handlers async functions\n    const hasAsync = traverse.hasType(\n      fn.body,\n      \"AwaitExpression\",\n      t.FUNCTION_TYPES,\n    );\n    if (hasAsync) {\n      fn.async = true;\n      call = t.awaitExpression(call);\n      basePath = \".argument\" + basePath;\n    }\n\n    let placeholderPath;\n    let index;\n    if (this.has.hasReturn || this.has.hasBreakContinue) {\n      const ret = this.scope.generateUid(\"ret\");\n\n      this.body.push(\n        t.variableDeclaration(\"var\", [\n          t.variableDeclarator(t.identifier(ret), call),\n        ]),\n      );\n      placeholderPath = \"declarations.0.init\" + basePath;\n      index = this.body.length - 1;\n\n      this.buildHas(ret);\n    } else {\n      this.body.push(t.expressionStatement(call));\n      placeholderPath = \"expression\" + basePath;\n      index = this.body.length - 1;\n    }\n\n    let callPath: NodePath;\n    // replace the current block body with the one we're going to build\n    if (isSwitch) {\n      const { parentPath, listKey, key } = this.blockPath;\n\n      this.blockPath.replaceWithMultiple(this.body);\n      callPath = parentPath.get(listKey)[(key as number) + index];\n    } else {\n      block.body = this.body;\n      callPath = this.blockPath.get(\"body\")[index];\n    }\n\n    const placeholder = callPath.get(placeholderPath) as NodePath;\n\n    let fnPath;\n    if (this.loop) {\n      const loopId = this.scope.generateUid(\"loop\");\n      const p = this.loopPath.insertBefore(\n        t.variableDeclaration(\"var\", [\n          t.variableDeclarator(t.identifier(loopId), fn),\n        ]),\n      );\n\n      placeholder.replaceWith(t.identifier(loopId));\n      fnPath = p[0].get(\"declarations.0.init\");\n    } else {\n      placeholder.replaceWith(fn);\n      fnPath = placeholder;\n    }\n\n    // Ensure \"this\", \"arguments\", and \"super\" continue to work in the wrapped function.\n    fnPath.unwrapFunctionEnvironment();\n  }\n\n  /**\n   * If any of the outer let variables are reassigned then we need to rename them in\n   * the closure so we can get direct access to the outer variable to continue the\n   * iteration with bindings based on each iteration.\n   *\n   * Reference: https://github.com/babel/babel/issues/1078\n   */\n\n  addContinuations(fn: t.FunctionExpression & { params: t.Identifier[] }) {\n    const state: ContinuationVisitorState = {\n      reassignments: {},\n      returnStatements: [],\n      outsideReferences: this.outsideLetReferences,\n    };\n\n    this.scope.traverse(fn, continuationVisitor, state);\n\n    for (let i = 0; i < fn.params.length; i++) {\n      const param = fn.params[i];\n      if (!state.reassignments[param.name]) continue;\n\n      const paramName = param.name;\n      const newParamName = this.scope.generateUid(param.name);\n      fn.params[i] = t.identifier(newParamName);\n\n      this.scope.rename(paramName, newParamName, fn);\n\n      state.returnStatements.forEach(returnStatement => {\n        returnStatement.insertBefore(\n          t.expressionStatement(\n            t.assignmentExpression(\n              \"=\",\n              t.identifier(paramName),\n              t.identifier(newParamName),\n            ),\n          ),\n        );\n      });\n\n      // assign outer reference as it's been modified internally and needs to be retained\n      fn.body.body.push(\n        t.expressionStatement(\n          t.assignmentExpression(\n            \"=\",\n            t.identifier(paramName),\n            t.identifier(newParamName),\n          ),\n        ),\n      );\n    }\n  }\n\n  getLetReferences() {\n    const block = this.block;\n\n    const declarators = [];\n\n    if (this.loop) {\n      // @ts-expect-error todo(flow->ts) add check for loop type\n      const init = this.loop.left || this.loop.init;\n      if (isBlockScoped(init)) {\n        declarators.push(init);\n        const names = t.getBindingIdentifiers(init);\n        for (const name of Object.keys(names)) {\n          this.outsideLetReferences.set(name, names[name]);\n        }\n      }\n    }\n\n    const addDeclarationsFromChild = (\n      path: NodePath<t.Statement | t.SwitchCase>,\n      node: t.Statement | t.SwitchCase,\n    ) => {\n      if (\n        t.isClassDeclaration(node) ||\n        t.isFunctionDeclaration(node) ||\n        isBlockScoped(node)\n      ) {\n        if (isBlockScoped(node)) {\n          convertBlockScopedToVar(\n            path as NodePath<t.VariableDeclaration>,\n            node,\n            block,\n            this.scope,\n          );\n        }\n        if (node.type === \"VariableDeclaration\") {\n          for (let i = 0; i < node.declarations.length; i++) {\n            declarators.push(node.declarations[i]);\n          }\n        } else {\n          declarators.push(node);\n        }\n      }\n      if (t.isLabeledStatement(node)) {\n        addDeclarationsFromChild(path.get(\"body\"), node.body);\n      }\n    };\n\n    if (block.type === \"SwitchStatement\") {\n      const declarPaths = (this.blockPath as NodePath<t.SwitchStatement>).get(\n        \"cases\",\n      );\n      for (let i = 0; i < block.cases.length; i++) {\n        const consequents = block.cases[i].consequent;\n\n        for (let j = 0; j < consequents.length; j++) {\n          const declar = consequents[j];\n          addDeclarationsFromChild(declarPaths[i], declar);\n        }\n      }\n    } else {\n      const declarPaths = (this.blockPath as NodePath<t.Block>).get(\"body\");\n      for (let i = 0; i < block.body.length; i++) {\n        addDeclarationsFromChild(declarPaths[i], declarPaths[i].node);\n      }\n    }\n\n    //\n    for (let i = 0; i < declarators.length; i++) {\n      const declar = declarators[i];\n      // Passing true as the third argument causes t.getBindingIdentifiers\n      // to return only the *outer* binding identifiers of this\n      // declaration, rather than (for example) mistakenly including the\n      // parameters of a function declaration. Fixes #4880.\n      const keys = t.getBindingIdentifiers(declar, false, true);\n      for (const key of Object.keys(keys)) {\n        this.letReferences.set(key, keys[key]);\n      }\n      this.hasLetReferences = true;\n    }\n\n    // no let references so we can just quit\n    if (!this.hasLetReferences) return;\n\n    const state: LetReferenceVisitorState = {\n      letReferences: this.letReferences,\n      closurify: false,\n      loopDepth: 0,\n      tdzEnabled: this.tdzEnabled,\n      addHelper: name => this.state.addHelper(name),\n    };\n\n    if (isInLoop(this.blockPath)) {\n      state.loopDepth++;\n    }\n\n    // traverse through this block, stopping on functions and checking if they\n    // contain any local let references\n    this.blockPath.traverse(letReferenceBlockVisitor, state);\n\n    return state.closurify;\n  }\n\n  /**\n   * If we're inside of a loop then traverse it and check if it has one of\n   * the following node types `ReturnStatement`, `BreakStatement`,\n   * `ContinueStatement` and replace it with a return value that we can track\n   * later on.\n   */\n\n  checkLoop() {\n    const state: LoopVisitorState = {\n      hasBreakContinue: false,\n      ignoreLabeless: false,\n      inSwitchCase: false,\n      innerLabels: [],\n      hasReturn: false,\n      isLoop: !!this.loop,\n      map: new Map(),\n      loopIgnored: new WeakSet(),\n    };\n\n    this.blockPath.traverse(loopLabelVisitor, state);\n    this.blockPath.traverse(loopVisitor, state);\n\n    return state;\n  }\n\n  /**\n   * Hoist all let declarations in this block to before it so they retain scope\n   * once we wrap everything in a closure.\n   */\n\n  hoistVarDeclarations() {\n    this.blockPath.traverse(hoistVarDeclarationsVisitor, this);\n  }\n\n  /**\n   * Turn a `VariableDeclaration` into an array of `AssignmentExpressions` with\n   * their declarations hoisted to before the closure wrapper.\n   */\n\n  pushDeclar(node: t.VariableDeclaration): Array<t.AssignmentExpression> {\n    const declars = [];\n    const names = t.getBindingIdentifiers(node);\n    for (const name of Object.keys(names)) {\n      declars.push(t.variableDeclarator(names[name]));\n    }\n\n    this.body.push(t.variableDeclaration(node.kind, declars));\n\n    const replace = [];\n\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      if (!declar.init) continue;\n\n      const expr = t.assignmentExpression(\n        \"=\",\n        t.cloneNode(declar.id),\n        t.cloneNode(declar.init),\n      );\n      replace.push(t.inherits(expr, declar));\n    }\n\n    return replace;\n  }\n\n  buildHas(ret: string) {\n    const body = this.body;\n    const has = this.has;\n\n    if (has.hasBreakContinue) {\n      for (const key of has.map.keys()) {\n        body.push(\n          t.ifStatement(\n            t.binaryExpression(\"===\", t.identifier(ret), t.stringLiteral(key)),\n            has.map.get(key),\n          ),\n        );\n      }\n    }\n\n    // typeof ret === \"object\"\n    if (has.hasReturn) {\n      body.push(\n        buildRetCheck({\n          RETURN: t.identifier(ret),\n        }),\n      );\n    }\n  }\n}\n"],"mappings":"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"}
=======
{"version":3,"names":["DONE","WeakSet","declare","api","opts","assertVersion","throwIfClosureRequired","tdz","tdzEnabled","Error","name","visitor","VariableDeclaration","path","node","parent","scope","isBlockScoped","convertBlockScopedToVar","_tdzThis","nodes","i","declarations","length","decl","assign","t","assignmentExpression","cloneNode","id","init","buildUndefinedNode","_ignoreBlockScopingTDZ","push","expressionStatement","addHelper","_blockHoist","isCompletionRecord","replaceWithMultiple","Loop","state","ensureBlock","blockScoping","BlockScoping","get","replace","run","replaceWith","CatchClause","ignoreBlock","isLoop","isCatchClause","buildRetCheck","template","statement","isVariableDeclaration","BLOCK_SCOPED_SYMBOL","kind","isInLoop","loopOrFunctionParent","find","isFunction","moveBindingsToParent","isFor","declar","parentScope","getFunctionParent","getProgramParent","Object","keys","getBindingIdentifiers","binding","getOwnBinding","moveBindingTo","isVar","letReferenceBlockVisitor","traverse","visitors","merge","enter","loopDepth","exit","FunctionParent","letReferenceFunctionVisitor","tdzVisitor","skip","ReferencedIdentifier","ref","letReferences","localBinding","getBindingIdentifier","closurify","hoistVarDeclarationsVisitor","self","isForStatement","pushDeclar","sequenceExpression","isForInStatement","isForOfStatement","left","map","expr","loopLabelVisitor","LabeledStatement","innerLabels","label","continuationVisitor","isAssignmentExpression","isUpdateExpression","outsideReferences","reassignments","isReturnStatement","returnStatements","loopNodeTo","isBreakStatement","isContinueStatement","loopVisitor","oldIgnoreLabeless","ignoreLabeless","Function","SwitchCase","oldInSwitchCase","inSwitchCase","loopIgnored","has","loopText","indexOf","hasBreakContinue","set","stringLiteral","hasReturn","objectExpression","objectProperty","identifier","argument","returnStatement","add","inherits","isStrict","isProgram","sourceType","isBlockStatement","directives","some","directive","value","constructor","loopPath","blockPath","block","outsideLetReferences","hasLetReferences","body","loopParent","loopLabel","loop","Map","isLabeledStatement","needsClosure","getLetReferences","checkConstants","updateScopeInfo","wrapClosure","remap","labeledStatement","constBindings","Set","bindings","violation","constantViolations","readOnlyError","throwNode","callExpression","operator","includes","logicalExpression","slice","binaryExpression","unaryExpression","isForXStatement","variableDeclaration","variableDeclarator","generateUidIdentifier","unshift","wrappedInClosure","blockScope","letRefs","key","getBinding","hasOwnBinding","removeBinding","outsideLetRefs","blockPathScope","parentHasBinding","hasGlobal","parentBinding","async","generator","parentPath","rename","buildCodeFrameError","outsideRefs","Array","from","delete","checkLoop","hoistVarDeclarations","args","values","params","isSwitch","type","fn","functionExpression","blockStatement","addContinuations","call","nullLiteral","basePath","hasYield","hasType","FUNCTION_TYPES","yieldExpression","hasAsync","awaitExpression","placeholderPath","index","ret","generateUid","buildHas","callPath","listKey","placeholder","fnPath","loopId","p","insertBefore","unwrapFunctionEnvironment","param","paramName","newParamName","forEach","declarators","names","addDeclarationsFromChild","isClassDeclaration","isFunctionDeclaration","declarPaths","cases","consequents","consequent","j","declars","ifStatement","RETURN"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport type { NodePath, Visitor, Scope, Binding } from \"@babel/traverse\";\nimport { visitor as tdzVisitor } from \"./tdz\";\nimport type { TDZVisitorState } from \"./tdz\";\nimport { traverse, template, types as t } from \"@babel/core\";\nimport type { PluginPass } from \"@babel/core\";\n\nconst DONE = new WeakSet();\n\nexport interface Options {\n  tdz?: boolean;\n  throwIfClosureRequired?: boolean;\n}\n\nexport default declare((api, opts: Options) => {\n  api.assertVersion(7);\n\n  const { throwIfClosureRequired = false, tdz: tdzEnabled = false } = opts;\n  if (typeof throwIfClosureRequired !== \"boolean\") {\n    throw new Error(`.throwIfClosureRequired must be a boolean, or undefined`);\n  }\n  if (typeof tdzEnabled !== \"boolean\") {\n    throw new Error(`.tdz must be a boolean, or undefined`);\n  }\n\n  return {\n    name: \"transform-block-scoping\",\n\n    visitor: {\n      VariableDeclaration(path) {\n        const { node, parent, scope } = path;\n        if (!isBlockScoped(node)) return;\n        convertBlockScopedToVar(path, null, parent, scope, true);\n\n        // @ts-expect-error todo(flow->ts): avoid mutations\n        if (node._tdzThis) {\n          const nodes: t.Node[] = [node];\n\n          for (let i = 0; i < node.declarations.length; i++) {\n            const decl = node.declarations[i];\n            const assign = t.assignmentExpression(\n              \"=\",\n              t.cloneNode(decl.id),\n              decl.init || scope.buildUndefinedNode(),\n            );\n            // @ts-expect-error todo(flow->ts): avoid mutations\n            assign._ignoreBlockScopingTDZ = true;\n            nodes.push(t.expressionStatement(assign));\n            decl.init = this.addHelper(\"temporalUndefined\");\n          }\n\n          // @ts-expect-error todo(flow->ts): avoid mutations\n          node._blockHoist = 2;\n\n          if (path.isCompletionRecord()) {\n            // ensure we don't break completion record semantics by returning\n            // the initialiser of the last declarator\n            nodes.push(t.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          path.replaceWithMultiple(nodes);\n        }\n      },\n\n      Loop(path: NodePath<t.Loop>, state) {\n        const { parent, scope } = path;\n        path.ensureBlock();\n        const blockScoping = new BlockScoping(\n          path,\n          path.get(\"body\"),\n          parent,\n          scope,\n          throwIfClosureRequired,\n          tdzEnabled,\n          state,\n        );\n        const replace = blockScoping.run();\n        if (replace) path.replaceWith(replace);\n      },\n\n      CatchClause(path, state) {\n        const { parent, scope } = path;\n        const blockScoping = new BlockScoping(\n          null,\n          path.get(\"body\"),\n          parent,\n          scope,\n          throwIfClosureRequired,\n          tdzEnabled,\n          state,\n        );\n        blockScoping.run();\n      },\n\n      \"BlockStatement|SwitchStatement|Program\"(\n        path: NodePath<t.BlockStatement | t.SwitchStatement | t.Program>,\n        state,\n      ) {\n        if (!ignoreBlock(path)) {\n          const blockScoping = new BlockScoping(\n            null,\n            path,\n            path.parent,\n            path.scope,\n            throwIfClosureRequired,\n            tdzEnabled,\n            state,\n          );\n          blockScoping.run();\n        }\n      },\n    },\n  };\n});\n\nfunction ignoreBlock(\n  path: NodePath<t.BlockStatement | t.SwitchStatement | t.Program>,\n) {\n  return t.isLoop(path.parent) || t.isCatchClause(path.parent);\n}\n\nconst buildRetCheck = template.statement(`\n  if (typeof RETURN === \"object\") return RETURN.v;\n`);\n\nfunction isBlockScoped(node: t.Node): node is t.VariableDeclaration {\n  if (!t.isVariableDeclaration(node)) return false;\n  if (\n    // @ts-expect-error Fixme: document symbol properties\n    node[t.BLOCK_SCOPED_SYMBOL]\n  ) {\n    return true;\n  }\n\n  if (node.kind !== \"let\" && node.kind !== \"const\") return false;\n  return true;\n}\n\n/**\n * If there is a loop ancestor closer than the closest function, we\n * consider ourselves to be in a loop.\n */\nfunction isInLoop(path: NodePath) {\n  const loopOrFunctionParent = path.find(\n    path => path.isLoop() || path.isFunction(),\n  );\n\n  return loopOrFunctionParent?.isLoop();\n}\n\nfunction convertBlockScopedToVar(\n  path: NodePath<t.VariableDeclaration>,\n  node: t.VariableDeclaration,\n  parent: t.Node,\n  scope: Scope,\n  moveBindingsToParent = false,\n) {\n  if (!node) {\n    node = path.node;\n  }\n\n  // https://github.com/babel/babel/issues/255\n  if (isInLoop(path) && !t.isFor(parent)) {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      declar.init = declar.init || scope.buildUndefinedNode();\n    }\n  }\n\n  // @ts-expect-error todo(flow->ts): avoid mutations\n  node[t.BLOCK_SCOPED_SYMBOL] = true;\n  node.kind = \"var\";\n\n  // Move bindings from current block scope to function scope.\n  if (moveBindingsToParent) {\n    const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n    for (const name of Object.keys(path.getBindingIdentifiers())) {\n      const binding = scope.getOwnBinding(name);\n      if (binding) binding.kind = \"var\";\n      scope.moveBindingTo(name, parentScope);\n    }\n  }\n}\n\nfunction isVar(node: t.Node): node is t.VariableDeclaration {\n  return t.isVariableDeclaration(node, { kind: \"var\" }) && !isBlockScoped(node);\n}\n\ninterface LetReferenceVisitorState extends TDZVisitorState {\n  loopDepth: number;\n  closurify: boolean;\n}\n\nconst letReferenceBlockVisitor = traverse.visitors.merge([\n  {\n    Loop: {\n      enter(path, state) {\n        state.loopDepth++;\n      },\n      exit(path, state) {\n        state.loopDepth--;\n      },\n    },\n    FunctionParent(path, state) {\n      // References to block-scoped variables only require added closures if it's\n      // possible for the code to run more than once -- otherwise it is safe to\n      // simply rename the variables.\n      if (state.loopDepth > 0) {\n        path.traverse(letReferenceFunctionVisitor, state);\n      } else {\n        path.traverse(tdzVisitor, state);\n      }\n      return path.skip();\n    },\n  },\n  tdzVisitor,\n] as Visitor<LetReferenceVisitorState>[]);\n\nconst letReferenceFunctionVisitor = traverse.visitors.merge([\n  {\n    ReferencedIdentifier(path, state) {\n      const ref = state.letReferences.get(path.node.name);\n\n      // not a part of our scope\n      if (!ref) return;\n\n      // this scope has a variable with the same name so it couldn't belong\n      // to our let scope\n      const localBinding = path.scope.getBindingIdentifier(path.node.name);\n      if (localBinding && localBinding !== ref) return;\n\n      state.closurify = true;\n    },\n  },\n  tdzVisitor,\n] as Visitor<LetReferenceVisitorState>[]);\n\nconst hoistVarDeclarationsVisitor: Visitor<BlockScoping> = {\n  enter(path, self) {\n    if (path.isForStatement()) {\n      const { node } = path;\n      if (isVar(node.init)) {\n        const nodes = self.pushDeclar(node.init);\n        if (nodes.length === 1) {\n          node.init = nodes[0];\n        } else {\n          node.init = t.sequenceExpression(nodes);\n        }\n      }\n    } else if (path.isForInStatement() || path.isForOfStatement()) {\n      const { node } = path;\n      if (isVar(node.left)) {\n        self.pushDeclar(node.left);\n        node.left = node.left.declarations[0].id;\n      }\n    } else if (isVar(path.node)) {\n      path.replaceWithMultiple(\n        self.pushDeclar(path.node).map(expr => t.expressionStatement(expr)),\n      );\n    } else if (path.isFunction()) {\n      return path.skip();\n    }\n  },\n};\n\ntype LoopVisitorState = {\n  inSwitchCase: boolean;\n  hasBreakContinue: boolean;\n  innerLabels: string[];\n  hasReturn: boolean;\n  ignoreLabeless: boolean;\n  loopIgnored: WeakSet<t.Node>;\n  isLoop: boolean;\n  map: Map<string, t.BreakStatement | t.ContinueStatement>;\n};\n\nconst loopLabelVisitor: Visitor<LoopVisitorState> = {\n  LabeledStatement({ node }, state) {\n    state.innerLabels.push(node.label.name);\n  },\n};\n\ninterface ContinuationVisitorState {\n  returnStatements: NodePath<t.ReturnStatement>[];\n  reassignments: { [k: string]: boolean | undefined };\n  outsideReferences: Map<string, t.Identifier>;\n}\n\nconst continuationVisitor: Visitor<ContinuationVisitorState> = {\n  enter(path, state) {\n    if (path.isAssignmentExpression() || path.isUpdateExpression()) {\n      for (const name of Object.keys(path.getBindingIdentifiers())) {\n        if (\n          state.outsideReferences.get(name) !==\n          path.scope.getBindingIdentifier(name)\n        ) {\n          continue;\n        }\n        state.reassignments[name] = true;\n      }\n    } else if (path.isReturnStatement()) {\n      state.returnStatements.push(path);\n    }\n  },\n};\n\nfunction loopNodeTo(node: t.Node) {\n  if (t.isBreakStatement(node)) {\n    return \"break\";\n  } else if (t.isContinueStatement(node)) {\n    return \"continue\";\n  }\n}\n\nconst loopVisitor: Visitor<LoopVisitorState> = {\n  Loop(path, state) {\n    const oldIgnoreLabeless = state.ignoreLabeless;\n    state.ignoreLabeless = true;\n    path.traverse(loopVisitor, state);\n    state.ignoreLabeless = oldIgnoreLabeless;\n    path.skip();\n  },\n\n  Function(path) {\n    path.skip();\n  },\n\n  SwitchCase(path, state) {\n    const oldInSwitchCase = state.inSwitchCase;\n    state.inSwitchCase = true;\n    path.traverse(loopVisitor, state);\n    state.inSwitchCase = oldInSwitchCase;\n    path.skip();\n  },\n\n  \"BreakStatement|ContinueStatement|ReturnStatement\"(\n    path: NodePath<t.BreakStatement | t.ContinueStatement | t.ReturnStatement>,\n    state,\n  ) {\n    const { node, scope } = path;\n    if (state.loopIgnored.has(node)) return;\n\n    let replace;\n    let loopText = loopNodeTo(node);\n\n    if (loopText) {\n      if (t.isReturnStatement(node)) {\n        throw new Error(\n          \"Internal error: unexpected return statement with `loopText`\",\n        );\n      }\n      if (node.label) {\n        // we shouldn't be transforming this because it exists somewhere inside\n        if (state.innerLabels.indexOf(node.label.name) >= 0) {\n          return;\n        }\n\n        loopText = `${loopText}|${node.label.name}`;\n      } else {\n        // we shouldn't be transforming these statements because\n        // they don't refer to the actual loop we're scopifying\n        if (state.ignoreLabeless) return;\n\n        // break statements mean something different in this context\n        if (t.isBreakStatement(node) && state.inSwitchCase) return;\n      }\n\n      state.hasBreakContinue = true;\n      state.map.set(loopText, node);\n      replace = t.stringLiteral(loopText);\n    }\n\n    if (t.isReturnStatement(node)) {\n      state.hasReturn = true;\n      replace = t.objectExpression([\n        t.objectProperty(\n          t.identifier(\"v\"),\n          node.argument || scope.buildUndefinedNode(),\n        ),\n      ]);\n    }\n\n    if (replace) {\n      replace = t.returnStatement(replace);\n      state.loopIgnored.add(replace);\n      path.skip();\n      path.replaceWith(t.inherits(replace, node));\n    }\n  },\n};\n\nfunction isStrict(path: NodePath) {\n  return !!path.find(({ node }) => {\n    if (t.isProgram(node)) {\n      if (node.sourceType === \"module\") return true;\n    } else if (!t.isBlockStatement(node)) return false;\n\n    return node.directives.some(\n      directive => directive.value.value === \"use strict\",\n    );\n  });\n}\n\nclass BlockScoping {\n  private parent: t.Node;\n  private state: PluginPass;\n  private scope: Scope;\n  private throwIfClosureRequired: boolean;\n  private tdzEnabled: boolean;\n  private blockPath: NodePath<t.Block | t.SwitchStatement>;\n  private block: t.Block | t.SwitchStatement;\n  private outsideLetReferences: Map<string, t.Identifier>;\n  private hasLetReferences: boolean;\n  private letReferences: Map<string, t.Identifier>;\n  private body: t.Statement[];\n  // todo(flow->ts) add more specific type\n  private loopParent: t.Node;\n  private loopLabel: t.Identifier;\n  private loopPath: NodePath<t.Loop>;\n  private loop: t.Loop;\n  private has: LoopVisitorState;\n  constructor(\n    loopPath: NodePath<t.Loop> | undefined | null,\n    blockPath: NodePath<t.Block | t.SwitchStatement>,\n    parent: t.Node,\n    scope: Scope,\n    throwIfClosureRequired: boolean,\n    tdzEnabled: boolean,\n    state: PluginPass,\n  ) {\n    this.parent = parent;\n    this.scope = scope;\n    this.state = state;\n    this.throwIfClosureRequired = throwIfClosureRequired;\n    this.tdzEnabled = tdzEnabled;\n\n    this.blockPath = blockPath;\n    this.block = blockPath.node;\n\n    this.outsideLetReferences = new Map();\n    this.hasLetReferences = false;\n    this.letReferences = new Map();\n    this.body = [];\n\n    if (loopPath) {\n      this.loopParent = loopPath.parent;\n      this.loopLabel =\n        t.isLabeledStatement(this.loopParent) && this.loopParent.label;\n      this.loopPath = loopPath;\n      this.loop = loopPath.node;\n    }\n  }\n\n  /**\n   * Start the ball rolling.\n   */\n\n  run() {\n    const block = this.block;\n    if (DONE.has(block)) return;\n    DONE.add(block);\n\n    const needsClosure = this.getLetReferences();\n\n    this.checkConstants();\n\n    // this is a block within a `Function/Program` so we can safely leave it be\n    if (t.isFunction(this.parent) || t.isProgram(this.block)) {\n      this.updateScopeInfo();\n      return;\n    }\n\n    // we can skip everything\n    if (!this.hasLetReferences) return;\n\n    if (needsClosure) {\n      this.wrapClosure();\n    } else {\n      this.remap();\n    }\n\n    this.updateScopeInfo(needsClosure);\n\n    if (this.loopLabel && !t.isLabeledStatement(this.loopParent)) {\n      return t.labeledStatement(this.loopLabel, this.loop);\n    }\n  }\n\n  checkConstants() {\n    const constBindings = new Map<string, Binding>();\n\n    // In some cases, there are two different scopes: for example,\n    // for (const x of y) {} has a scope for the loop head and one\n    // for the body.\n    for (const scope of new Set([this.scope, this.blockPath.scope])) {\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        if (binding.kind === \"const\") constBindings.set(name, binding);\n      }\n    }\n\n    const { state } = this;\n\n    for (const [name, binding] of constBindings) {\n      for (const violation of binding.constantViolations) {\n        const readOnlyError = state.addHelper(\"readOnlyError\");\n        const throwNode = t.callExpression(readOnlyError, [\n          t.stringLiteral(name),\n        ]);\n\n        if (violation.isAssignmentExpression()) {\n          const { operator } = violation.node;\n          if (operator === \"=\") {\n            violation.replaceWith(\n              t.sequenceExpression([violation.get(\"right\").node, throwNode]),\n            );\n          } else if ([\"&&=\", \"||=\", \"??=\"].includes(operator)) {\n            violation.replaceWith(\n              t.logicalExpression(\n                // @ts-expect-error todo(flow->ts)\n                operator.slice(0, -1),\n                violation.get(\"left\").node,\n                t.sequenceExpression([violation.get(\"right\").node, throwNode]),\n              ),\n            );\n          } else {\n            violation.replaceWith(\n              t.sequenceExpression([\n                t.binaryExpression(\n                  // @ts-expect-error todo(flow->ts)\n                  operator.slice(0, -1),\n                  violation.get(\"left\").node,\n                  violation.get(\"right\").node,\n                ),\n                throwNode,\n              ]),\n            );\n          }\n        } else if (violation.isUpdateExpression()) {\n          violation.replaceWith(\n            t.sequenceExpression([\n              t.unaryExpression(\"+\", violation.get(\"argument\").node),\n              throwNode,\n            ]),\n          );\n        } else if (violation.isForXStatement()) {\n          // @ts-expect-error TS requires explicit annotation of \"violation\"\n          violation.ensureBlock();\n          violation\n            .get(\"left\")\n            .replaceWith(\n              t.variableDeclaration(\"var\", [\n                t.variableDeclarator(\n                  violation.scope.generateUidIdentifier(name),\n                ),\n              ]),\n            );\n          // @ts-expect-error todo(flow->ts): possible bug \"for(â€¦) switch(){}\"\n          violation.node.body.body.unshift(t.expressionStatement(throwNode));\n        }\n      }\n    }\n  }\n\n  updateScopeInfo(wrappedInClosure?: boolean) {\n    const blockScope = this.blockPath.scope;\n\n    const parentScope =\n      blockScope.getFunctionParent() || blockScope.getProgramParent();\n    const letRefs = this.letReferences;\n\n    for (const key of letRefs.keys()) {\n      const ref = letRefs.get(key);\n      const binding = blockScope.getBinding(ref.name);\n      if (!binding) continue;\n      if (binding.kind === \"let\" || binding.kind === \"const\") {\n        binding.kind = \"var\";\n\n        if (wrappedInClosure) {\n          if (blockScope.hasOwnBinding(ref.name)) {\n            blockScope.removeBinding(ref.name);\n          }\n        } else {\n          blockScope.moveBindingTo(ref.name, parentScope);\n        }\n      }\n    }\n  }\n\n  remap() {\n    const letRefs = this.letReferences;\n    const outsideLetRefs = this.outsideLetReferences;\n    const scope = this.scope;\n    const blockPathScope = this.blockPath.scope;\n\n    // alright, so since we aren't wrapping this block in a closure\n    // we have to check if any of our let variables collide with\n    // those in upper scopes and then if they do, generate a uid\n    // for them and replace all references with it\n\n    for (const key of letRefs.keys()) {\n      // just an Identifier node we collected in `getLetReferences`\n      // this is the defining identifier of a declaration\n      const ref = letRefs.get(key);\n\n      // todo: could skip this if the colliding binding is in another function\n      if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {\n        const binding = scope.getOwnBinding(key);\n        if (binding) {\n          const parentBinding = scope.parent.getOwnBinding(key);\n          if (\n            binding.kind === \"hoisted\" &&\n            // @ts-expect-error todo(flow->ts)\n            !binding.path.node.async &&\n            // @ts-expect-error todo(flow->ts)\n            !binding.path.node.generator &&\n            (!parentBinding || isVar(parentBinding.path.parent)) &&\n            !isStrict(binding.path.parentPath)\n          ) {\n            continue;\n          }\n          // The same identifier might have been bound separately in the block scope and\n          // the enclosing scope (e.g. loop or catch statement), so we should handle both\n          // individually\n          scope.rename(ref.name);\n        }\n\n        if (blockPathScope.hasOwnBinding(key)) {\n          blockPathScope.rename(ref.name);\n        }\n      }\n    }\n\n    for (const key of outsideLetRefs.keys()) {\n      const ref = letRefs.get(key);\n      // check for collisions with a for loop's init variable and the enclosing scope's bindings\n      // https://github.com/babel/babel/issues/8498\n      if (isInLoop(this.blockPath) && blockPathScope.hasOwnBinding(key)) {\n        blockPathScope.rename(ref.name);\n      }\n    }\n  }\n\n  wrapClosure() {\n    if (this.throwIfClosureRequired) {\n      throw this.blockPath.buildCodeFrameError(\n        \"Compiling let/const in this block would add a closure \" +\n          \"(throwIfClosureRequired).\",\n      );\n    }\n    const block = this.block;\n\n    const outsideRefs = this.outsideLetReferences;\n\n    // remap loop heads with colliding variables\n    if (this.loop) {\n      // nb: clone outsideRefs keys since the map is modified within the loop\n      for (const name of Array.from(outsideRefs.keys())) {\n        const id = outsideRefs.get(name);\n\n        if (\n          this.scope.hasGlobal(id.name) ||\n          this.scope.parentHasBinding(id.name)\n        ) {\n          outsideRefs.delete(id.name);\n          this.letReferences.delete(id.name);\n\n          this.scope.rename(id.name);\n\n          this.letReferences.set(id.name, id);\n          outsideRefs.set(id.name, id);\n        }\n      }\n    }\n\n    // if we're inside of a for loop then we search to see if there are any\n    // `break`s, `continue`s, `return`s etc\n    this.has = this.checkLoop();\n\n    // hoist let references to retain scope\n    this.hoistVarDeclarations();\n\n    // turn outsideLetReferences into an array\n    const args = Array.from(outsideRefs.values(), node => t.cloneNode(node));\n    const params = args.map(id => t.cloneNode(id));\n\n    const isSwitch = block.type === \"SwitchStatement\";\n\n    // build the closure that we're going to wrap the block with, possible wrapping switch(){}\n    const fn = t.functionExpression(\n      null,\n      params,\n      t.blockStatement(isSwitch ? [block] : block.body),\n    ) as t.FunctionExpression & { params: t.Identifier[] };\n\n    // continuation\n    this.addContinuations(fn);\n\n    let call: t.CallExpression | t.YieldExpression | t.AwaitExpression =\n      t.callExpression(t.nullLiteral(), args);\n    let basePath = \".callee\";\n\n    // handle generators\n    const hasYield = traverse.hasType(\n      fn.body,\n      \"YieldExpression\",\n      t.FUNCTION_TYPES,\n    );\n    if (hasYield) {\n      fn.generator = true;\n      call = t.yieldExpression(call, true);\n      basePath = \".argument\" + basePath;\n    }\n\n    // handlers async functions\n    const hasAsync = traverse.hasType(\n      fn.body,\n      \"AwaitExpression\",\n      t.FUNCTION_TYPES,\n    );\n    if (hasAsync) {\n      fn.async = true;\n      call = t.awaitExpression(call);\n      basePath = \".argument\" + basePath;\n    }\n\n    let placeholderPath;\n    let index;\n    if (this.has.hasReturn || this.has.hasBreakContinue) {\n      const ret = this.scope.generateUid(\"ret\");\n\n      this.body.push(\n        t.variableDeclaration(\"var\", [\n          t.variableDeclarator(t.identifier(ret), call),\n        ]),\n      );\n      placeholderPath = \"declarations.0.init\" + basePath;\n      index = this.body.length - 1;\n\n      this.buildHas(ret);\n    } else {\n      this.body.push(t.expressionStatement(call));\n      placeholderPath = \"expression\" + basePath;\n      index = this.body.length - 1;\n    }\n\n    let callPath: NodePath;\n    // replace the current block body with the one we're going to build\n    if (isSwitch) {\n      const { parentPath, listKey, key } = this.blockPath;\n\n      this.blockPath.replaceWithMultiple(this.body);\n      callPath = parentPath.get(listKey)[(key as number) + index];\n    } else {\n      block.body = this.body;\n      callPath = this.blockPath.get(\"body\")[index];\n    }\n\n    const placeholder = callPath.get(placeholderPath) as NodePath;\n\n    let fnPath;\n    if (this.loop) {\n      const loopId = this.scope.generateUid(\"loop\");\n      const p = this.loopPath.insertBefore(\n        t.variableDeclaration(\"var\", [\n          t.variableDeclarator(t.identifier(loopId), fn),\n        ]),\n      );\n\n      placeholder.replaceWith(t.identifier(loopId));\n      fnPath = p[0].get(\"declarations.0.init\");\n    } else {\n      placeholder.replaceWith(fn);\n      fnPath = placeholder;\n    }\n\n    // Ensure \"this\", \"arguments\", and \"super\" continue to work in the wrapped function.\n    fnPath.unwrapFunctionEnvironment();\n  }\n\n  /**\n   * If any of the outer let variables are reassigned then we need to rename them in\n   * the closure so we can get direct access to the outer variable to continue the\n   * iteration with bindings based on each iteration.\n   *\n   * Reference: https://github.com/babel/babel/issues/1078\n   */\n\n  addContinuations(fn: t.FunctionExpression & { params: t.Identifier[] }) {\n    const state: ContinuationVisitorState = {\n      reassignments: {},\n      returnStatements: [],\n      outsideReferences: this.outsideLetReferences,\n    };\n\n    this.scope.traverse(fn, continuationVisitor, state);\n\n    for (let i = 0; i < fn.params.length; i++) {\n      const param = fn.params[i];\n      if (!state.reassignments[param.name]) continue;\n\n      const paramName = param.name;\n      const newParamName = this.scope.generateUid(param.name);\n      fn.params[i] = t.identifier(newParamName);\n\n      this.scope.rename(paramName, newParamName, fn);\n\n      state.returnStatements.forEach(returnStatement => {\n        returnStatement.insertBefore(\n          t.expressionStatement(\n            t.assignmentExpression(\n              \"=\",\n              t.identifier(paramName),\n              t.identifier(newParamName),\n            ),\n          ),\n        );\n      });\n\n      // assign outer reference as it's been modified internally and needs to be retained\n      fn.body.body.push(\n        t.expressionStatement(\n          t.assignmentExpression(\n            \"=\",\n            t.identifier(paramName),\n            t.identifier(newParamName),\n          ),\n        ),\n      );\n    }\n  }\n\n  getLetReferences() {\n    const block = this.block;\n\n    const declarators = [];\n\n    if (this.loop) {\n      // @ts-expect-error todo(flow->ts) add check for loop type\n      const init = this.loop.left || this.loop.init;\n      if (isBlockScoped(init)) {\n        declarators.push(init);\n        const names = t.getBindingIdentifiers(init);\n        for (const name of Object.keys(names)) {\n          this.outsideLetReferences.set(name, names[name]);\n        }\n      }\n    }\n\n    const addDeclarationsFromChild = (\n      path: NodePath<t.Statement | t.SwitchCase>,\n      node: t.Statement | t.SwitchCase,\n    ) => {\n      if (\n        t.isClassDeclaration(node) ||\n        t.isFunctionDeclaration(node) ||\n        isBlockScoped(node)\n      ) {\n        if (isBlockScoped(node)) {\n          convertBlockScopedToVar(\n            path as NodePath<t.VariableDeclaration>,\n            node,\n            block,\n            this.scope,\n          );\n        }\n        if (node.type === \"VariableDeclaration\") {\n          for (let i = 0; i < node.declarations.length; i++) {\n            declarators.push(node.declarations[i]);\n          }\n        } else {\n          declarators.push(node);\n        }\n      }\n      if (t.isLabeledStatement(node)) {\n        addDeclarationsFromChild(path.get(\"body\"), node.body);\n      }\n    };\n\n    if (block.type === \"SwitchStatement\") {\n      const declarPaths = (this.blockPath as NodePath<t.SwitchStatement>).get(\n        \"cases\",\n      );\n      for (let i = 0; i < block.cases.length; i++) {\n        const consequents = block.cases[i].consequent;\n\n        for (let j = 0; j < consequents.length; j++) {\n          const declar = consequents[j];\n          addDeclarationsFromChild(declarPaths[i], declar);\n        }\n      }\n    } else {\n      const declarPaths = (this.blockPath as NodePath<t.Block>).get(\"body\");\n      for (let i = 0; i < block.body.length; i++) {\n        addDeclarationsFromChild(declarPaths[i], declarPaths[i].node);\n      }\n    }\n\n    //\n    for (let i = 0; i < declarators.length; i++) {\n      const declar = declarators[i];\n      // Passing true as the third argument causes t.getBindingIdentifiers\n      // to return only the *outer* binding identifiers of this\n      // declaration, rather than (for example) mistakenly including the\n      // parameters of a function declaration. Fixes #4880.\n      const keys = t.getBindingIdentifiers(declar, false, true);\n      for (const key of Object.keys(keys)) {\n        this.letReferences.set(key, keys[key]);\n      }\n      this.hasLetReferences = true;\n    }\n\n    // no let references so we can just quit\n    if (!this.hasLetReferences) return;\n\n    const state: LetReferenceVisitorState = {\n      letReferences: this.letReferences,\n      closurify: false,\n      loopDepth: 0,\n      tdzEnabled: this.tdzEnabled,\n      addHelper: name => this.state.addHelper(name),\n    };\n\n    if (isInLoop(this.blockPath)) {\n      state.loopDepth++;\n    }\n\n    // traverse through this block, stopping on functions and checking if they\n    // contain any local let references\n    this.blockPath.traverse(letReferenceBlockVisitor, state);\n\n    return state.closurify;\n  }\n\n  /**\n   * If we're inside of a loop then traverse it and check if it has one of\n   * the following node types `ReturnStatement`, `BreakStatement`,\n   * `ContinueStatement` and replace it with a return value that we can track\n   * later on.\n   */\n\n  checkLoop() {\n    const state: LoopVisitorState = {\n      hasBreakContinue: false,\n      ignoreLabeless: false,\n      inSwitchCase: false,\n      innerLabels: [],\n      hasReturn: false,\n      isLoop: !!this.loop,\n      map: new Map(),\n      loopIgnored: new WeakSet(),\n    };\n\n    this.blockPath.traverse(loopLabelVisitor, state);\n    this.blockPath.traverse(loopVisitor, state);\n\n    return state;\n  }\n\n  /**\n   * Hoist all let declarations in this block to before it so they retain scope\n   * once we wrap everything in a closure.\n   */\n\n  hoistVarDeclarations() {\n    this.blockPath.traverse(hoistVarDeclarationsVisitor, this);\n  }\n\n  /**\n   * Turn a `VariableDeclaration` into an array of `AssignmentExpressions` with\n   * their declarations hoisted to before the closure wrapper.\n   */\n\n  pushDeclar(node: t.VariableDeclaration): Array<t.AssignmentExpression> {\n    const declars = [];\n    const names = t.getBindingIdentifiers(node);\n    for (const name of Object.keys(names)) {\n      declars.push(t.variableDeclarator(names[name]));\n    }\n\n    this.body.push(t.variableDeclaration(node.kind, declars));\n\n    const replace = [];\n\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      if (!declar.init) continue;\n\n      const expr = t.assignmentExpression(\n        \"=\",\n        t.cloneNode(declar.id),\n        t.cloneNode(declar.init),\n      );\n      replace.push(t.inherits(expr, declar));\n    }\n\n    return replace;\n  }\n\n  buildHas(ret: string) {\n    const body = this.body;\n    const has = this.has;\n\n    if (has.hasBreakContinue) {\n      for (const key of has.map.keys()) {\n        body.push(\n          t.ifStatement(\n            t.binaryExpression(\"===\", t.identifier(ret), t.stringLiteral(key)),\n            has.map.get(key),\n          ),\n        );\n      }\n    }\n\n    // typeof ret === \"object\"\n    if (has.hasReturn) {\n      body.push(\n        buildRetCheck({\n          RETURN: t.identifier(ret),\n        }),\n      );\n    }\n  }\n}\n"],"mappings":"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"}
>>>>>>> main
