<<<<<<< HEAD
{"version":3,"names":["getTDZStatus","refPath","bindingPath","executionStatus","_guessExecutionStatusRelativeTo","buildTDZAssert","node","state","t","callExpression","addHelper","stringLiteral","name","isReference","scope","declared","letReferences","get","getBindingIdentifier","visitedMaybeTDZNodes","WeakSet","visitor","ReferencedIdentifier","path","tdzEnabled","parent","parentPath","isFor","left","getBinding","isFunctionDeclaration","status","has","add","assert","_tdzThis","isUpdateExpression","_ignoreBlockScopingTDZ","replaceWith","sequenceExpression","template","ast","AssignmentExpression","exit","nodes","ids","getBindingIdentifiers","Object","keys","id","push","length","replaceWithMultiple","map","n","expressionStatement"],"sources":["../src/tdz.ts"],"sourcesContent":["import { types as t, template, type PluginPass } from \"@babel/core\";\nimport type { NodePath, Scope, Visitor } from \"@babel/traverse\";\n\nfunction getTDZStatus(\n  refPath: NodePath<t.Identifier | t.JSXIdentifier>,\n  bindingPath: NodePath,\n) {\n  const executionStatus = bindingPath._guessExecutionStatusRelativeTo(refPath);\n\n  if (executionStatus === \"before\") {\n    return \"outside\";\n  } else if (executionStatus === \"after\") {\n    return \"inside\";\n  } else {\n    return \"maybe\";\n  }\n}\n\nfunction buildTDZAssert(\n  node: t.Identifier | t.JSXIdentifier,\n  state: TDZVisitorState,\n) {\n  return t.callExpression(state.addHelper(\"temporalRef\"), [\n    // @ts-expect-error Fixme: we may need to handle JSXIdentifier\n    node,\n    t.stringLiteral(node.name),\n  ]);\n}\n\nfunction isReference(\n  node: t.Identifier | t.JSXIdentifier,\n  scope: Scope,\n  state: TDZVisitorState,\n) {\n  const declared = state.letReferences.get(node.name);\n  if (!declared) return false;\n\n  // declared node is different in this scope\n  return scope.getBindingIdentifier(node.name) === declared;\n}\n\nconst visitedMaybeTDZNodes = new WeakSet();\n\nexport interface TDZVisitorState {\n  tdzEnabled: boolean;\n  addHelper: PluginPass[\"addHelper\"];\n  letReferences: Map<string, t.Identifier>;\n}\n\nexport const visitor: Visitor<TDZVisitorState> = {\n  ReferencedIdentifier(path, state) {\n    if (!state.tdzEnabled) return;\n\n    const { node, parent, scope } = path;\n\n    if (path.parentPath.isFor({ left: node })) return;\n    if (!isReference(node, scope, state)) return;\n\n    const bindingPath = scope.getBinding(node.name).path;\n\n    if (bindingPath.isFunctionDeclaration()) return;\n\n    const status = getTDZStatus(path, bindingPath);\n    if (status === \"outside\") return;\n\n    if (status === \"maybe\") {\n      if (visitedMaybeTDZNodes.has(node)) {\n        return;\n      }\n      visitedMaybeTDZNodes.add(node);\n      const assert = buildTDZAssert(node, state);\n\n      // add tdzThis to parent variable declarator so it's exploded\n      // @ts-expect-error todo(flow->ts): avoid mutations\n      bindingPath.parent._tdzThis = true;\n\n      if (path.parentPath.isUpdateExpression()) {\n        // @ts-expect-error todo(flow->ts): avoid node mutations\n        if (parent._ignoreBlockScopingTDZ) return;\n        path.parentPath.replaceWith(\n          t.sequenceExpression([assert, parent as t.UpdateExpression]),\n        );\n      } else {\n        path.replaceWith(assert);\n      }\n    } else if (status === \"inside\") {\n      path.replaceWith(\n        template.ast`${state.addHelper(\"tdz\")}(\"${node.name}\")` as t.Statement,\n      );\n    }\n  },\n\n  AssignmentExpression: {\n    exit(path, state) {\n      if (!state.tdzEnabled) return;\n\n      const { node } = path;\n\n      // @ts-expect-error todo(flow->ts): avoid node mutations\n      if (node._ignoreBlockScopingTDZ) return;\n\n      const nodes = [];\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        const id = ids[name];\n\n        if (isReference(id, path.scope, state)) {\n          nodes.push(id);\n        }\n      }\n\n      if (nodes.length) {\n        // @ts-expect-error todo(flow->ts): avoid mutations\n        node._ignoreBlockScopingTDZ = true;\n        nodes.push(node);\n        path.replaceWithMultiple(nodes.map(n => t.expressionStatement(n)));\n      }\n    },\n  },\n};\n"],"mappings":"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"}
=======
{"version":3,"names":["getTDZStatus","refPath","bindingPath","executionStatus","_guessExecutionStatusRelativeTo","buildTDZAssert","node","state","t","callExpression","addHelper","stringLiteral","name","isReference","scope","declared","letReferences","get","getBindingIdentifier","visitedMaybeTDZNodes","WeakSet","visitor","ReferencedIdentifier","path","tdzEnabled","parent","parentPath","isFor","left","getBinding","isFunctionDeclaration","status","has","add","assert","_tdzThis","isUpdateExpression","_ignoreBlockScopingTDZ","replaceWith","sequenceExpression","template","ast","AssignmentExpression","exit","nodes","ids","getBindingIdentifiers","Object","keys","id","push","length","replaceWithMultiple","map","n","expressionStatement"],"sources":["../src/tdz.ts"],"sourcesContent":["import { types as t, template, type PluginPass } from \"@babel/core\";\nimport type { NodePath, Scope, Visitor } from \"@babel/traverse\";\n\nfunction getTDZStatus(\n  refPath: NodePath<t.Identifier | t.JSXIdentifier>,\n  bindingPath: NodePath,\n) {\n  const executionStatus = bindingPath._guessExecutionStatusRelativeTo(refPath);\n\n  if (executionStatus === \"before\") {\n    return \"outside\";\n  } else if (executionStatus === \"after\") {\n    return \"inside\";\n  } else {\n    return \"maybe\";\n  }\n}\n\nfunction buildTDZAssert(\n  node: t.Identifier | t.JSXIdentifier,\n  state: TDZVisitorState,\n) {\n  return t.callExpression(state.addHelper(\"temporalRef\"), [\n    // @ts-expect-error Fixme: we may need to handle JSXIdentifier\n    node,\n    t.stringLiteral(node.name),\n  ]);\n}\n\nfunction isReference(\n  node: t.Identifier | t.JSXIdentifier,\n  scope: Scope,\n  state: TDZVisitorState,\n) {\n  const declared = state.letReferences.get(node.name);\n  if (!declared) return false;\n\n  // declared node is different in this scope\n  return scope.getBindingIdentifier(node.name) === declared;\n}\n\nconst visitedMaybeTDZNodes = new WeakSet();\n\nexport interface TDZVisitorState {\n  tdzEnabled: boolean;\n  addHelper: PluginPass[\"addHelper\"];\n  letReferences: Map<string, t.Identifier>;\n}\n\nexport const visitor: Visitor<TDZVisitorState> = {\n  ReferencedIdentifier(path, state) {\n    if (!state.tdzEnabled) return;\n\n    const { node, parent, scope } = path;\n\n    if (path.parentPath.isFor({ left: node })) return;\n    if (!isReference(node, scope, state)) return;\n\n    const bindingPath = scope.getBinding(node.name).path;\n\n    if (bindingPath.isFunctionDeclaration()) return;\n\n    const status = getTDZStatus(path, bindingPath);\n    if (status === \"outside\") return;\n\n    if (status === \"maybe\") {\n      if (visitedMaybeTDZNodes.has(node)) {\n        return;\n      }\n      visitedMaybeTDZNodes.add(node);\n      const assert = buildTDZAssert(node, state);\n\n      // add tdzThis to parent variable declarator so it's exploded\n      // @ts-expect-error todo(flow->ts): avoid mutations\n      bindingPath.parent._tdzThis = true;\n\n      if (path.parentPath.isUpdateExpression()) {\n        // @ts-expect-error todo(flow->ts): avoid node mutations\n        if (parent._ignoreBlockScopingTDZ) return;\n        path.parentPath.replaceWith(\n          t.sequenceExpression([assert, parent as t.UpdateExpression]),\n        );\n      } else {\n        path.replaceWith(assert);\n      }\n    } else if (status === \"inside\") {\n      path.replaceWith(\n        template.ast`${state.addHelper(\"tdz\")}(\"${node.name}\")` as t.Statement,\n      );\n    }\n  },\n\n  AssignmentExpression: {\n    exit(path, state) {\n      if (!state.tdzEnabled) return;\n\n      const { node } = path;\n\n      // @ts-expect-error todo(flow->ts): avoid node mutations\n      if (node._ignoreBlockScopingTDZ) return;\n\n      const nodes = [];\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        const id = ids[name];\n\n        if (isReference(id, path.scope, state)) {\n          nodes.push(id);\n        }\n      }\n\n      if (nodes.length) {\n        // @ts-expect-error todo(flow->ts): avoid mutations\n        node._ignoreBlockScopingTDZ = true;\n        nodes.push(node);\n        path.replaceWithMultiple(nodes.map(n => t.expressionStatement(n)));\n      }\n    },\n  },\n};\n"],"mappings":"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"}
>>>>>>> main
