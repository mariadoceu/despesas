<<<<<<< HEAD
{"version":3,"names":["NOT_LOCAL_BINDING","callExpression","cloneNode","getBindingIdentifiers","identifier","isArrayExpression","isBinary","isClass","isClassBody","isClassDeclaration","isExportAllDeclaration","isExportDefaultDeclaration","isExportNamedDeclaration","isFunctionDeclaration","isIdentifier","isImportDeclaration","isLiteral","isMethod","isModuleDeclaration","isModuleSpecifier","isNullLiteral","isObjectExpression","isProperty","isPureish","isRegExpLiteral","isSuper","isTaggedTemplateExpression","isTemplateLiteral","isThisExpression","isUnaryExpression","isVariableDeclaration","matchesPattern","memberExpression","numericLiteral","toIdentifier","unaryExpression","variableDeclaration","variableDeclarator","isRecordExpression","isTupleExpression","isObjectProperty","isTopicReference","isMetaProperty","isPrivateName","gatherNodeParts","node","parts","type","source","specifiers","length","e","declaration","local","push","value","object","property","name","callee","properties","argument","key","left","id","expression","meta","openingElement","openingFragment","namespace","collectorVisitor","ForStatement","path","declar","get","isVar","scope","parentScope","getFunctionParent","getProgramParent","registerBinding","Declaration","isBlockScoped","isExportDeclaration","parent","registerDeclaration","ImportDeclaration","getBlockParent","ReferencedIdentifier","state","references","ForXStatement","isPattern","constantViolations","ExportDeclaration","exit","binding","getBinding","reference","decl","declarations","Object","keys","LabeledStatement","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","BlockScoped","bindings","CatchClause","Function","params","param","isFunctionExpression","has","ClassExpression","uid","Scope","constructor","block","labels","inited","globals","uids","data","crawling","cached","scopeCache","set","Map","shouldSkip","listKey","parentPath","isScope","parentBlock","hub","traverse","opts","generateDeclaredUidIdentifier","generateUidIdentifier","generateUid","replace","i","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","generateUidBasedOnNode","defaultName","join","slice","generateUidIdentifierBasedOnNode","isStatic","constant","maybeGenerateMemoised","dontPush","checkBlockScopedCollisions","kind","duplicate","buildError","TypeError","rename","oldName","newName","Renamer","_renameFromMap","map","dump","sep","repeat","console","log","violations","toArray","arrayLikeIsIterable","isGenericType","helperName","args","unshift","addHelper","getLabel","registerLabel","label","isLabeledStatement","declare","specifier","buildUndefinedNode","registerConstantViolation","ids","reassign","bindingPath","ReferenceError","declarators","getOuterBindingIdentifiers","getOwnBinding","Binding","addGlobal","hasUid","isPure","constantsOnly","superClass","decorators","body","method","right","elem","elements","prop","computed","static","tag","quasi","expressions","setData","val","getData","removeData","init","crawl","create","programParent","_exploded","visit","enter","typeVisitors","ref","getPatternParent","isBlockStatement","isProgram","isSwitchStatement","isLoop","isCatchClause","isFunction","ensureBlock","unique","blockHoist","_blockHoist","dataKey","declarPath","unshiftContainer","declarator","len","Error","isFunctionParent","isBlockParent","getAllBindings","getAllBindingsOfKind","kinds","bindingIdentifierEquals","getBindingIdentifier","previousPath","isArrowFunctionExpression","getOwnBindingIdentifier","hasOwnBinding","noGlobals","parentHasBinding","includes","contextVariables","moveBindingTo","info","removeOwnBinding","removeBinding","builtin"],"sources":["../../src/scope/index.ts"],"sourcesContent":["import Renamer from \"./lib/renamer\";\nimport type NodePath from \"../path\";\nimport traverse from \"../index\";\nimport type { TraverseOptions } from \"../index\";\nimport Binding from \"./binding\";\nimport type { BindingKind } from \"./binding\";\nimport globals from \"globals\";\nimport {\n  NOT_LOCAL_BINDING,\n  callExpression,\n  cloneNode,\n  getBindingIdentifiers,\n  identifier,\n  isArrayExpression,\n  isBinary,\n  isClass,\n  isClassBody,\n  isClassDeclaration,\n  isExportAllDeclaration,\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n  isFunctionDeclaration,\n  isIdentifier,\n  isImportDeclaration,\n  isLiteral,\n  isMethod,\n  isModuleDeclaration,\n  isModuleSpecifier,\n  isNullLiteral,\n  isObjectExpression,\n  isProperty,\n  isPureish,\n  isRegExpLiteral,\n  isSuper,\n  isTaggedTemplateExpression,\n  isTemplateLiteral,\n  isThisExpression,\n  isUnaryExpression,\n  isVariableDeclaration,\n  matchesPattern,\n  memberExpression,\n  numericLiteral,\n  toIdentifier,\n  unaryExpression,\n  variableDeclaration,\n  variableDeclarator,\n  isRecordExpression,\n  isTupleExpression,\n  isObjectProperty,\n  isTopicReference,\n  isMetaProperty,\n  isPrivateName,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { scope as scopeCache } from \"../cache\";\nimport type { Visitor } from \"../types\";\n\ntype NodePart = string | number | boolean;\n// Recursively gathers the identifying names of a node.\nfunction gatherNodeParts(node: t.Node, parts: NodePart[]) {\n  switch (node?.type) {\n    default:\n      if (isModuleDeclaration(node)) {\n        if (\n          (isExportAllDeclaration(node) ||\n            isExportNamedDeclaration(node) ||\n            isImportDeclaration(node)) &&\n          node.source\n        ) {\n          gatherNodeParts(node.source, parts);\n        } else if (\n          (isExportNamedDeclaration(node) || isImportDeclaration(node)) &&\n          node.specifiers &&\n          node.specifiers.length\n        ) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if (\n          (isExportDefaultDeclaration(node) ||\n            isExportNamedDeclaration(node)) &&\n          node.declaration\n        ) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (isModuleSpecifier(node)) {\n        // todo(flow->ts): should condition instead be:\n        //    ```\n        //    t.isExportSpecifier(node) ||\n        //    t.isImportDefaultSpecifier(node) ||\n        //    t.isImportNamespaceSpecifier(node) ||\n        //    t.isImportSpecifier(node)\n        //    ```\n        //    allowing only nodes with `.local`?\n        // @ts-expect-error todo(flow->ts)\n        gatherNodeParts(node.local, parts);\n      } else if (\n        isLiteral(node) &&\n        !isNullLiteral(node) &&\n        !isRegExpLiteral(node) &&\n        !isTemplateLiteral(node)\n      ) {\n        parts.push(node.value);\n      }\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      gatherNodeParts(node.name, parts);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\n//\ninterface CollectVisitorState {\n  assignments: NodePath<t.AssignmentExpression>[];\n  references: NodePath<t.Identifier | t.JSXIdentifier>[];\n  constantViolations: NodePath[];\n}\n\nconst collectorVisitor: Visitor<CollectVisitorState> = {\n  ForStatement(path) {\n    const declar = path.get(\"init\");\n    // delegate block scope handling to the `BlockScoped` method\n    if (declar.isVar()) {\n      const { scope } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", declar);\n    }\n  },\n\n  Declaration(path) {\n    // delegate block scope handling to the `BlockScoped` method\n    if (path.isBlockScoped()) return;\n\n    // delegate import handing to the `ImportDeclaration` method\n    if (path.isImportDeclaration()) return;\n\n    // this will be hit again once we traverse into it after this iteration\n    if (path.isExportDeclaration()) return;\n\n    // we've ran into a declaration!\n    const parent =\n      path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ImportDeclaration(path) {\n    // import may only appear in the top level or inside a module/namespace (for TS/flow)\n    const parent = path.scope.getBlockParent();\n\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n    // delegate block scope handling to the `BlockScoped` method\n    else if (left.isVar()) {\n      const { scope } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", left);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const { node, scope } = path;\n      // ExportAllDeclaration does not have `declaration`\n      if (isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n      if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n\n        const binding = scope.getBinding(id.name);\n        binding?.reference(path);\n      } else if (isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            binding?.reference(path);\n          }\n        }\n      }\n    },\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    // Register class identifier in class' scope if this is a class declaration.\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    const params: Array<NodePath> = path.get(\"params\");\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n\n    // Register function expression id after params. When the id\n    // collides with a function param, the id effectively can't be\n    // referenced: here we registered it as a constantViolation\n    if (\n      path.isFunctionExpression() &&\n      path.has(\"id\") &&\n      // @ts-expect-error Fixme: document symbol ast properties\n      !path.get(\"id\").node[NOT_LOCAL_BINDING]\n    ) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n  },\n\n  ClassExpression(path) {\n    if (\n      path.has(\"id\") &&\n      // @ts-expect-error Fixme: document symbol ast properties\n      !path.get(\"id\").node[NOT_LOCAL_BINDING]\n    ) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  },\n};\n\nlet uid = 0;\n\nexport type { Binding };\n\nexport default class Scope {\n  uid;\n\n  path: NodePath;\n  block: t.Pattern | t.Scopable;\n\n  labels;\n  inited;\n\n  bindings: { [name: string]: Binding };\n  references: { [name: string]: true };\n  globals: { [name: string]: t.Identifier | t.JSXIdentifier };\n  uids: { [name: string]: boolean };\n  data: { [key: string | symbol]: unknown };\n  crawling: boolean;\n\n  /**\n   * This searches the current \"scope\" and collects all references/bindings\n   * within.\n   */\n  constructor(path: NodePath<t.Pattern | t.Scopable>) {\n    const { node } = path;\n    const cached = scopeCache.get(node);\n    // Sometimes, a scopable path is placed higher in the AST tree.\n    // In these cases, have to create a new Scope.\n    if (cached?.path === path) {\n      return cached;\n    }\n    scopeCache.set(node, this);\n\n    this.uid = uid++;\n\n    this.block = node;\n    this.path = path;\n\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  /**\n   * Globals.\n   */\n\n  static globals = Object.keys(globals.builtin);\n\n  /**\n   * Variables available in current context.\n   */\n\n  static contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];\n\n  get parent() {\n    let parent,\n      path = this.path;\n    do {\n      // Skip method scope if coming from inside computed key or decorator expression\n      const shouldSkip = path.key === \"key\" || path.listKey === \"decorators\";\n      path = path.parentPath;\n      if (shouldSkip && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return parent?.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse<S>(\n    node: t.Node | t.Node[],\n    opts: TraverseOptions<S>,\n    state: S,\n  ): void;\n  traverse(node: t.Node | t.Node[], opts?: TraverseOptions, state?: any): void;\n  /**\n   * Traverse node with current scope and path.\n   */\n  traverse<S>(node: any, opts: any, state?: S) {\n    traverse(node, opts, this, state, this.path);\n  }\n\n  /**\n   * Generate a unique identifier and add it to the current scope.\n   */\n\n  generateDeclaredUidIdentifier(name?: string) {\n    const id = this.generateUidIdentifier(name);\n    this.push({ id });\n    return cloneNode(id);\n  }\n\n  /**\n   * Generate a unique identifier.\n   */\n\n  generateUidIdentifier(name?: string) {\n    return identifier(this.generateUid(name));\n  }\n\n  /**\n   * Generate a unique `_id1` binding.\n   */\n\n  generateUid(name: string = \"temp\"): string {\n    name = toIdentifier(name)\n      .replace(/^_+/, \"\")\n      .replace(/[0-9]+$/g, \"\");\n\n    let uid;\n    let i = 1;\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (\n      this.hasLabel(uid) ||\n      this.hasBinding(uid) ||\n      this.hasGlobal(uid) ||\n      this.hasReference(uid)\n    );\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n\n    return uid;\n  }\n\n  /**\n   * Generate an `_id1`.\n   */\n\n  _generateUid(name: string, i: number) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node: t.Node, defaultName?: string) {\n    const parts: NodePart[] = [];\n    gatherNodeParts(node, parts);\n\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  /**\n   * Generate a unique identifier based on a node.\n   */\n\n  generateUidIdentifierBasedOnNode(node: t.Node, defaultName?: string) {\n    return identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  /**\n   * Determine whether evaluating the specific input `node` is a consequenceless reference. ie.\n   * evaluating it wont result in potentially arbitrary code from being ran. The following are\n   * allowed and determined not to cause side effects:\n   *\n   *  - `this` expressions\n   *  - `super` expressions\n   *  - Bound identifiers\n   */\n\n  isStatic(node: t.Node): boolean {\n    if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) {\n      return true;\n    }\n\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Possibly generate a memoised identifier if it is not static and has consequences.\n   */\n\n  maybeGenerateMemoised(node: t.Node, dontPush?: boolean) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n      if (!dontPush) {\n        this.push({ id });\n        return cloneNode(id);\n      }\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(\n    local: Binding,\n    kind: BindingKind,\n    name: string,\n    id: any,\n  ) {\n    // ignore parameters\n    if (kind === \"param\") return;\n\n    // Ignore existing binding if it's the name of the current function or\n    // class expression\n    if (local.kind === \"local\") return;\n\n    const duplicate =\n      // don't allow duplicate bindings to exist alongside\n      kind === \"let\" ||\n      local.kind === \"let\" ||\n      local.kind === \"const\" ||\n      local.kind === \"module\" ||\n      // don't allow a local of param with a kind of let\n      (local.kind === \"param\" && kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(\n        id,\n        `Duplicate declaration \"${name}\"`,\n        TypeError,\n      );\n    }\n  }\n\n  rename(oldName: string, newName?: string, block?: t.Pattern | t.Scopable) {\n    const binding = this.getBinding(oldName);\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new Renamer(binding, oldName, newName).rename(block);\n    }\n  }\n\n  /** @deprecated Not used in our codebase */\n  _renameFromMap(\n    map: Record<string | symbol, unknown>,\n    oldName: string | symbol,\n    newName: string | symbol,\n    value: unknown,\n  ) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope: Scope = this;\n    do {\n      console.log(\"#\", scope.block.type);\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind,\n        });\n      }\n    } while ((scope = scope.parent));\n    console.log(sep);\n  }\n\n  // TODO: (Babel 8) Split i in two parameters, and use an object of flags\n  toArray(\n    node: t.Node,\n    i?: number | boolean,\n    arrayLikeIsIterable?: boolean | void,\n  ) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (binding?.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (isArrayExpression(node)) {\n      return node;\n    }\n\n    if (isIdentifier(node, { name: \"arguments\" })) {\n      return callExpression(\n        memberExpression(\n          memberExpression(\n            memberExpression(identifier(\"Array\"), identifier(\"prototype\")),\n            identifier(\"slice\"),\n          ),\n          identifier(\"call\"),\n        ),\n        [node],\n      );\n    }\n\n    let helperName;\n    const args = [node];\n    if (i === true) {\n      // Used in array-spread to create an array.\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(numericLiteral(i));\n\n      // Used in array-rest to create an array from a subset of an iterable.\n      helperName = \"slicedToArray\";\n      // TODO if (this.hub.isLoose(\"es6.forOf\")) helperName += \"-loose\";\n    } else {\n      // Used in array-rest to create an array\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    // @ts-expect-error todo(flow->ts): t.Node is not valid to use in args, function argument typeneeds to be clarified\n    return callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name: string) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name: string) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path: NodePath<t.LabeledStatement>) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path: NodePath) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n      const { kind } = path.node;\n      for (const declar of declarations) {\n        this.registerBinding(kind === \"using\" ? \"const\" : kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      if (path.node.declare) return;\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      // todo: improve babel-types\n      const declar = path.get(\"declaration\") as NodePath;\n      if (\n        declar.isClassDeclaration() ||\n        declar.isFunctionDeclaration() ||\n        declar.isVariableDeclaration()\n      ) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return unaryExpression(\"void\", numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path: NodePath) {\n    const ids = path.getBindingIdentifiers();\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(\n    kind: Binding[\"kind\"],\n    path: NodePath,\n    bindingPath: NodePath = path,\n  ) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators: Array<NodePath> = path.get(\"declarations\");\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          // same identifier so continue safely as we're likely trying to register it\n          // multiple times\n          if (local.identifier === id) continue;\n\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        // A redeclaration of an existing variable is a modification\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new Binding({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind,\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node: t.Identifier | t.JSXIdentifier) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name: string): boolean {\n    let scope: Scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while ((scope = scope.parent));\n\n    return false;\n  }\n\n  hasGlobal(name: string): boolean {\n    let scope: Scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while ((scope = scope.parent));\n\n    return false;\n  }\n\n  hasReference(name: string): boolean {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node: t.Node, constantsOnly?: boolean): boolean {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (\n      isThisExpression(node) ||\n      isMetaProperty(node) ||\n      isTopicReference(node) ||\n      isPrivateName(node)\n    ) {\n      return true;\n    } else if (isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n      if (node.decorators?.length > 0) {\n        return false;\n      }\n      return this.isPure(node.body, constantsOnly);\n    } else if (isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isBinary(node)) {\n      return (\n        this.isPure(node.left, constantsOnly) &&\n        this.isPure(node.right, constantsOnly)\n      );\n    } else if (isArrayExpression(node) || isTupleExpression(node)) {\n      for (const elem of node.elements) {\n        if (elem !== null && !this.isPure(elem, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isObjectExpression(node) || isRecordExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.decorators?.length > 0) {\n        return false;\n      }\n      return true;\n    } else if (isProperty(node)) {\n      // @ts-expect-error todo(flow->ts): computed in not present on private properties\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.decorators?.length > 0) {\n        return false;\n      }\n      if (isObjectProperty(node) || node.static) {\n        if (node.value !== null && !this.isPure(node.value, constantsOnly)) {\n          return false;\n        }\n      }\n      return true;\n    } else if (isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (isTaggedTemplateExpression(node)) {\n      return (\n        matchesPattern(node.tag, \"String.raw\") &&\n        !this.hasBinding(\"String\", true) &&\n        this.isPure(node.quasi, constantsOnly)\n      );\n    } else if (isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n      return true;\n    } else {\n      return isPureish(node);\n    }\n  }\n\n  /**\n   * Set some arbitrary data on the current scope.\n   */\n\n  setData(key: string | symbol, val: any) {\n    return (this.data[key] = val);\n  }\n\n  /**\n   * Recursively walk up scope tree looking for the data `key`.\n   */\n\n  getData(key: string | symbol): any {\n    let scope: Scope = this;\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while ((scope = scope.parent));\n  }\n\n  /**\n   * Recursively walk up scope tree looking for the data `key` and if it exists,\n   * remove it.\n   */\n\n  removeData(key: string) {\n    let scope: Scope = this;\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while ((scope = scope.parent));\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n\n    const state: CollectVisitorState = {\n      references: [],\n      constantViolations: [],\n      assignments: [],\n    };\n\n    this.crawling = true;\n    // traverse does not visit the root node, here we explicitly collect\n    // root node binding info when the root is not a Program.\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      // @ts-expect-error when collectorVisitor is exploded, `enter` always exists\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n      const typeVisitors = collectorVisitor[path.type];\n      if (typeVisitors) {\n        // @ts-expect-error when collectorVisitor is exploded, `enter` always exists\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    // register assignments\n    for (const path of state.assignments) {\n      // register undeclared bindings as globals\n      const ids = path.getBindingIdentifiers();\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      // register as constant violation\n      path.scope.registerConstantViolation(path);\n    }\n\n    // register references\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    // register constant violations\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts: {\n    id: t.LVal;\n    init?: t.Expression;\n    unique?: boolean;\n    _blockHoist?: number | undefined;\n    kind?: \"var\" | \"let\" | \"const\";\n  }) {\n    let path = this.path;\n\n    if (path.isPattern()) {\n      path = this.getPatternParent().path;\n    } else if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      // @ts-expect-error TS can not infer NodePath<Loop> | NodePath<CatchClause> as NodePath<Loop | CatchClause>\n      path.ensureBlock();\n      // @ts-expect-error todo(flow->ts): improve types\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = variableDeclaration(kind, []);\n      // @ts-expect-error todo(flow->ts): avoid modifying nodes\n      declar._blockHoist = blockHoist;\n\n      [declarPath] = (path as NodePath<t.BlockStatement>).unshiftContainer(\n        \"body\",\n        [declar],\n      );\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = variableDeclarator(opts.id, opts.init);\n    const len = declarPath.node.declarations.push(declarator);\n    path.scope.registerBinding(kind, declarPath.get(\"declarations\")[len - 1]);\n  }\n\n  /**\n   * Walk up to the top of the scope tree and get the `Program`.\n   */\n\n  getProgramParent() {\n    let scope: Scope = this;\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while ((scope = scope.parent));\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  /**\n   * Walk up the scope tree until we hit either a Function or return null.\n   */\n\n  getFunctionParent(): Scope | null {\n    let scope: Scope = this;\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while ((scope = scope.parent));\n    return null;\n  }\n\n  /**\n   * Walk up the scope tree until we hit either a BlockStatement/Loop/Program/Function/Switch or reach the\n   * very top and hit Program.\n   */\n\n  getBlockParent() {\n    let scope: Scope = this;\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while ((scope = scope.parent));\n    throw new Error(\n      \"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\",\n    );\n  }\n\n  /**\n   * Walk up from a pattern scope (function param initializer) until we hit a non-pattern scope,\n   * then returns its block parent\n   * @returns An ancestry scope whose path is a block parent\n   */\n  getPatternParent() {\n    let scope: Scope = this;\n    do {\n      if (!scope.path.isPattern()) {\n        return scope.getBlockParent();\n      }\n    } while ((scope = scope.parent.parent));\n    throw new Error(\n      \"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\",\n    );\n  }\n\n  /**\n   * Walks the scope tree and gathers **all** bindings.\n   */\n\n  getAllBindings(): Record<string, Binding> {\n    const ids = Object.create(null);\n\n    let scope: Scope = this;\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  /**\n   * Walks the scope tree and gathers all declarations of `kind`.\n   */\n\n  getAllBindingsOfKind(...kinds: string[]): Record<string, Binding> {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope: Scope = this;\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name: string, node: t.Node): boolean {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name: string): Binding | undefined {\n    let scope: Scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n      if (binding) {\n        // Check if a pattern is a part of parameter expressions.\n        // Note: for performance reason we skip checking previousPath.parentPath.isFunction()\n        // because `scope.path` is validated as scope in packages/babel-types/src/validators/isScope.js\n        // That is, if a scope path is pattern, its parent must be Function/CatchClause\n\n        // Spec 9.2.10.28: The closure created by this expression should not have visibility of\n        // declarations in the function body. If the binding is not a `param`-kind (as function parameters)\n        // or `local`-kind (as id in function expression),\n        // then it must be defined inside the function body, thus it should be skipped\n        if (\n          previousPath?.isPattern() &&\n          binding.kind !== \"param\" &&\n          binding.kind !== \"local\"\n        ) {\n          // do nothing\n        } else {\n          return binding;\n        }\n      } else if (\n        !binding &&\n        name === \"arguments\" &&\n        scope.path.isFunction() &&\n        !scope.path.isArrowFunctionExpression()\n      ) {\n        break;\n      }\n      previousPath = scope.path;\n    } while ((scope = scope.parent));\n  }\n\n  getOwnBinding(name: string): Binding | undefined {\n    return this.bindings[name];\n  }\n\n  // todo: return probably can be undefined…\n  getBindingIdentifier(name: string): t.Identifier {\n    return this.getBinding(name)?.identifier;\n  }\n\n  // todo: flow->ts return probably can be undefined\n  getOwnBindingIdentifier(name: string): t.Identifier {\n    const binding = this.bindings[name];\n    return binding?.identifier;\n  }\n\n  hasOwnBinding(name: string) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name: string, noGlobals?: boolean) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name: string, noGlobals?: boolean) {\n    return this.parent?.hasBinding(name, noGlobals);\n  }\n\n  /**\n   * Move a binding of `name` to another `scope`.\n   */\n\n  moveBindingTo(name: string, scope: Scope) {\n    const info = this.getBinding(name);\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name: string) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name: string) {\n    // clear literal binding\n    this.getBinding(name)?.scope.removeOwnBinding(name);\n\n    // clear uids with this name - https://github.com/babel/babel/issues/2101\n    let scope: Scope = this;\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while ((scope = scope.parent));\n  }\n}\n"],"mappings":"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"}
=======
{"version":3,"names":["NOT_LOCAL_BINDING","callExpression","cloneNode","getBindingIdentifiers","identifier","isArrayExpression","isBinary","isClass","isClassBody","isClassDeclaration","isExportAllDeclaration","isExportDefaultDeclaration","isExportNamedDeclaration","isFunctionDeclaration","isIdentifier","isImportDeclaration","isLiteral","isMethod","isModuleDeclaration","isModuleSpecifier","isNullLiteral","isObjectExpression","isProperty","isPureish","isRegExpLiteral","isSuper","isTaggedTemplateExpression","isTemplateLiteral","isThisExpression","isUnaryExpression","isVariableDeclaration","matchesPattern","memberExpression","numericLiteral","toIdentifier","unaryExpression","variableDeclaration","variableDeclarator","isRecordExpression","isTupleExpression","isObjectProperty","isTopicReference","isMetaProperty","isPrivateName","gatherNodeParts","node","parts","type","source","specifiers","length","e","declaration","local","push","value","object","property","name","callee","properties","argument","key","left","id","expression","meta","openingElement","openingFragment","namespace","collectorVisitor","ForStatement","path","declar","get","isVar","scope","parentScope","getFunctionParent","getProgramParent","registerBinding","Declaration","isBlockScoped","isExportDeclaration","parent","registerDeclaration","ImportDeclaration","getBlockParent","ReferencedIdentifier","state","references","ForXStatement","isPattern","constantViolations","ExportDeclaration","exit","binding","getBinding","reference","decl","declarations","Object","keys","LabeledStatement","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","BlockScoped","bindings","CatchClause","Function","params","param","isFunctionExpression","has","ClassExpression","uid","Scope","constructor","block","labels","inited","globals","uids","data","crawling","cached","scopeCache","set","Map","shouldSkip","listKey","parentPath","isScope","parentBlock","hub","traverse","opts","generateDeclaredUidIdentifier","generateUidIdentifier","generateUid","replace","i","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","generateUidBasedOnNode","defaultName","join","slice","generateUidIdentifierBasedOnNode","isStatic","constant","maybeGenerateMemoised","dontPush","checkBlockScopedCollisions","kind","duplicate","buildError","TypeError","rename","oldName","newName","Renamer","_renameFromMap","map","dump","sep","repeat","console","log","violations","toArray","arrayLikeIsIterable","isGenericType","helperName","args","unshift","addHelper","getLabel","registerLabel","label","isLabeledStatement","declare","specifier","buildUndefinedNode","registerConstantViolation","ids","reassign","bindingPath","ReferenceError","declarators","getOuterBindingIdentifiers","getOwnBinding","Binding","addGlobal","hasUid","isPure","constantsOnly","superClass","decorators","body","method","right","elem","elements","prop","computed","static","tag","quasi","expressions","setData","val","getData","removeData","init","crawl","create","programParent","_exploded","visit","enter","typeVisitors","ref","getPatternParent","isBlockStatement","isProgram","isSwitchStatement","isLoop","isCatchClause","isFunction","ensureBlock","unique","blockHoist","_blockHoist","dataKey","declarPath","unshiftContainer","declarator","len","Error","isFunctionParent","isBlockParent","getAllBindings","getAllBindingsOfKind","kinds","bindingIdentifierEquals","getBindingIdentifier","previousPath","isArrowFunctionExpression","getOwnBindingIdentifier","hasOwnBinding","noGlobals","parentHasBinding","includes","contextVariables","moveBindingTo","info","removeOwnBinding","removeBinding","builtin"],"sources":["../../src/scope/index.ts"],"sourcesContent":["import Renamer from \"./lib/renamer\";\nimport type NodePath from \"../path\";\nimport traverse from \"../index\";\nimport type { TraverseOptions } from \"../index\";\nimport Binding from \"./binding\";\nimport type { BindingKind } from \"./binding\";\nimport globals from \"globals\";\nimport {\n  NOT_LOCAL_BINDING,\n  callExpression,\n  cloneNode,\n  getBindingIdentifiers,\n  identifier,\n  isArrayExpression,\n  isBinary,\n  isClass,\n  isClassBody,\n  isClassDeclaration,\n  isExportAllDeclaration,\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n  isFunctionDeclaration,\n  isIdentifier,\n  isImportDeclaration,\n  isLiteral,\n  isMethod,\n  isModuleDeclaration,\n  isModuleSpecifier,\n  isNullLiteral,\n  isObjectExpression,\n  isProperty,\n  isPureish,\n  isRegExpLiteral,\n  isSuper,\n  isTaggedTemplateExpression,\n  isTemplateLiteral,\n  isThisExpression,\n  isUnaryExpression,\n  isVariableDeclaration,\n  matchesPattern,\n  memberExpression,\n  numericLiteral,\n  toIdentifier,\n  unaryExpression,\n  variableDeclaration,\n  variableDeclarator,\n  isRecordExpression,\n  isTupleExpression,\n  isObjectProperty,\n  isTopicReference,\n  isMetaProperty,\n  isPrivateName,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { scope as scopeCache } from \"../cache\";\nimport type { Visitor } from \"../types\";\n\ntype NodePart = string | number | boolean;\n// Recursively gathers the identifying names of a node.\nfunction gatherNodeParts(node: t.Node, parts: NodePart[]) {\n  switch (node?.type) {\n    default:\n      if (isModuleDeclaration(node)) {\n        if (\n          (isExportAllDeclaration(node) ||\n            isExportNamedDeclaration(node) ||\n            isImportDeclaration(node)) &&\n          node.source\n        ) {\n          gatherNodeParts(node.source, parts);\n        } else if (\n          (isExportNamedDeclaration(node) || isImportDeclaration(node)) &&\n          node.specifiers &&\n          node.specifiers.length\n        ) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if (\n          (isExportDefaultDeclaration(node) ||\n            isExportNamedDeclaration(node)) &&\n          node.declaration\n        ) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (isModuleSpecifier(node)) {\n        // todo(flow->ts): should condition instead be:\n        //    ```\n        //    t.isExportSpecifier(node) ||\n        //    t.isImportDefaultSpecifier(node) ||\n        //    t.isImportNamespaceSpecifier(node) ||\n        //    t.isImportSpecifier(node)\n        //    ```\n        //    allowing only nodes with `.local`?\n        // @ts-expect-error todo(flow->ts)\n        gatherNodeParts(node.local, parts);\n      } else if (\n        isLiteral(node) &&\n        !isNullLiteral(node) &&\n        !isRegExpLiteral(node) &&\n        !isTemplateLiteral(node)\n      ) {\n        parts.push(node.value);\n      }\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      gatherNodeParts(node.name, parts);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\n//\ninterface CollectVisitorState {\n  assignments: NodePath<t.AssignmentExpression>[];\n  references: NodePath<t.Identifier | t.JSXIdentifier>[];\n  constantViolations: NodePath[];\n}\n\nconst collectorVisitor: Visitor<CollectVisitorState> = {\n  ForStatement(path) {\n    const declar = path.get(\"init\");\n    // delegate block scope handling to the `BlockScoped` method\n    if (declar.isVar()) {\n      const { scope } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", declar);\n    }\n  },\n\n  Declaration(path) {\n    // delegate block scope handling to the `BlockScoped` method\n    if (path.isBlockScoped()) return;\n\n    // delegate import handing to the `ImportDeclaration` method\n    if (path.isImportDeclaration()) return;\n\n    // this will be hit again once we traverse into it after this iteration\n    if (path.isExportDeclaration()) return;\n\n    // we've ran into a declaration!\n    const parent =\n      path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ImportDeclaration(path) {\n    // import may only appear in the top level or inside a module/namespace (for TS/flow)\n    const parent = path.scope.getBlockParent();\n\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n    // delegate block scope handling to the `BlockScoped` method\n    else if (left.isVar()) {\n      const { scope } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", left);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const { node, scope } = path;\n      // ExportAllDeclaration does not have `declaration`\n      if (isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n      if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n\n        const binding = scope.getBinding(id.name);\n        binding?.reference(path);\n      } else if (isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            binding?.reference(path);\n          }\n        }\n      }\n    },\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    // Register class identifier in class' scope if this is a class declaration.\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    const params: Array<NodePath> = path.get(\"params\");\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n\n    // Register function expression id after params. When the id\n    // collides with a function param, the id effectively can't be\n    // referenced: here we registered it as a constantViolation\n    if (\n      path.isFunctionExpression() &&\n      path.has(\"id\") &&\n      // @ts-expect-error Fixme: document symbol ast properties\n      !path.get(\"id\").node[NOT_LOCAL_BINDING]\n    ) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n  },\n\n  ClassExpression(path) {\n    if (\n      path.has(\"id\") &&\n      // @ts-expect-error Fixme: document symbol ast properties\n      !path.get(\"id\").node[NOT_LOCAL_BINDING]\n    ) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  },\n};\n\nlet uid = 0;\n\nexport type { Binding };\n\nexport default class Scope {\n  uid;\n\n  path: NodePath;\n  block: t.Pattern | t.Scopable;\n\n  labels;\n  inited;\n\n  bindings: { [name: string]: Binding };\n  references: { [name: string]: true };\n  globals: { [name: string]: t.Identifier | t.JSXIdentifier };\n  uids: { [name: string]: boolean };\n  data: { [key: string | symbol]: unknown };\n  crawling: boolean;\n\n  /**\n   * This searches the current \"scope\" and collects all references/bindings\n   * within.\n   */\n  constructor(path: NodePath<t.Pattern | t.Scopable>) {\n    const { node } = path;\n    const cached = scopeCache.get(node);\n    // Sometimes, a scopable path is placed higher in the AST tree.\n    // In these cases, have to create a new Scope.\n    if (cached?.path === path) {\n      return cached;\n    }\n    scopeCache.set(node, this);\n\n    this.uid = uid++;\n\n    this.block = node;\n    this.path = path;\n\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  /**\n   * Globals.\n   */\n\n  static globals = Object.keys(globals.builtin);\n\n  /**\n   * Variables available in current context.\n   */\n\n  static contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];\n\n  get parent() {\n    let parent,\n      path = this.path;\n    do {\n      // Skip method scope if coming from inside computed key or decorator expression\n      const shouldSkip = path.key === \"key\" || path.listKey === \"decorators\";\n      path = path.parentPath;\n      if (shouldSkip && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return parent?.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse<S>(\n    node: t.Node | t.Node[],\n    opts: TraverseOptions<S>,\n    state: S,\n  ): void;\n  traverse(node: t.Node | t.Node[], opts?: TraverseOptions, state?: any): void;\n  /**\n   * Traverse node with current scope and path.\n   */\n  traverse<S>(node: any, opts: any, state?: S) {\n    traverse(node, opts, this, state, this.path);\n  }\n\n  /**\n   * Generate a unique identifier and add it to the current scope.\n   */\n\n  generateDeclaredUidIdentifier(name?: string) {\n    const id = this.generateUidIdentifier(name);\n    this.push({ id });\n    return cloneNode(id);\n  }\n\n  /**\n   * Generate a unique identifier.\n   */\n\n  generateUidIdentifier(name?: string) {\n    return identifier(this.generateUid(name));\n  }\n\n  /**\n   * Generate a unique `_id1` binding.\n   */\n\n  generateUid(name: string = \"temp\"): string {\n    name = toIdentifier(name)\n      .replace(/^_+/, \"\")\n      .replace(/[0-9]+$/g, \"\");\n\n    let uid;\n    let i = 1;\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (\n      this.hasLabel(uid) ||\n      this.hasBinding(uid) ||\n      this.hasGlobal(uid) ||\n      this.hasReference(uid)\n    );\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n\n    return uid;\n  }\n\n  /**\n   * Generate an `_id1`.\n   */\n\n  _generateUid(name: string, i: number) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node: t.Node, defaultName?: string) {\n    const parts: NodePart[] = [];\n    gatherNodeParts(node, parts);\n\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  /**\n   * Generate a unique identifier based on a node.\n   */\n\n  generateUidIdentifierBasedOnNode(node: t.Node, defaultName?: string) {\n    return identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  /**\n   * Determine whether evaluating the specific input `node` is a consequenceless reference. ie.\n   * evaluating it wont result in potentially arbitrary code from being ran. The following are\n   * allowed and determined not to cause side effects:\n   *\n   *  - `this` expressions\n   *  - `super` expressions\n   *  - Bound identifiers\n   */\n\n  isStatic(node: t.Node): boolean {\n    if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) {\n      return true;\n    }\n\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Possibly generate a memoised identifier if it is not static and has consequences.\n   */\n\n  maybeGenerateMemoised(node: t.Node, dontPush?: boolean) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n      if (!dontPush) {\n        this.push({ id });\n        return cloneNode(id);\n      }\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(\n    local: Binding,\n    kind: BindingKind,\n    name: string,\n    id: any,\n  ) {\n    // ignore parameters\n    if (kind === \"param\") return;\n\n    // Ignore existing binding if it's the name of the current function or\n    // class expression\n    if (local.kind === \"local\") return;\n\n    const duplicate =\n      // don't allow duplicate bindings to exist alongside\n      kind === \"let\" ||\n      local.kind === \"let\" ||\n      local.kind === \"const\" ||\n      local.kind === \"module\" ||\n      // don't allow a local of param with a kind of let\n      (local.kind === \"param\" && kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(\n        id,\n        `Duplicate declaration \"${name}\"`,\n        TypeError,\n      );\n    }\n  }\n\n  rename(oldName: string, newName?: string, block?: t.Pattern | t.Scopable) {\n    const binding = this.getBinding(oldName);\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new Renamer(binding, oldName, newName).rename(block);\n    }\n  }\n\n  /** @deprecated Not used in our codebase */\n  _renameFromMap(\n    map: Record<string | symbol, unknown>,\n    oldName: string | symbol,\n    newName: string | symbol,\n    value: unknown,\n  ) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope: Scope = this;\n    do {\n      console.log(\"#\", scope.block.type);\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind,\n        });\n      }\n    } while ((scope = scope.parent));\n    console.log(sep);\n  }\n\n  // TODO: (Babel 8) Split i in two parameters, and use an object of flags\n  toArray(\n    node: t.Node,\n    i?: number | boolean,\n    arrayLikeIsIterable?: boolean | void,\n  ) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (binding?.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (isArrayExpression(node)) {\n      return node;\n    }\n\n    if (isIdentifier(node, { name: \"arguments\" })) {\n      return callExpression(\n        memberExpression(\n          memberExpression(\n            memberExpression(identifier(\"Array\"), identifier(\"prototype\")),\n            identifier(\"slice\"),\n          ),\n          identifier(\"call\"),\n        ),\n        [node],\n      );\n    }\n\n    let helperName;\n    const args = [node];\n    if (i === true) {\n      // Used in array-spread to create an array.\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(numericLiteral(i));\n\n      // Used in array-rest to create an array from a subset of an iterable.\n      helperName = \"slicedToArray\";\n      // TODO if (this.hub.isLoose(\"es6.forOf\")) helperName += \"-loose\";\n    } else {\n      // Used in array-rest to create an array\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    // @ts-expect-error todo(flow->ts): t.Node is not valid to use in args, function argument typeneeds to be clarified\n    return callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name: string) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name: string) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path: NodePath<t.LabeledStatement>) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path: NodePath) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      if (path.node.declare) return;\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      // todo: improve babel-types\n      const declar = path.get(\"declaration\") as NodePath;\n      if (\n        declar.isClassDeclaration() ||\n        declar.isFunctionDeclaration() ||\n        declar.isVariableDeclaration()\n      ) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return unaryExpression(\"void\", numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path: NodePath) {\n    const ids = path.getBindingIdentifiers();\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(\n    kind: Binding[\"kind\"],\n    path: NodePath,\n    bindingPath: NodePath = path,\n  ) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators: Array<NodePath> = path.get(\"declarations\");\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          // same identifier so continue safely as we're likely trying to register it\n          // multiple times\n          if (local.identifier === id) continue;\n\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        // A redeclaration of an existing variable is a modification\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new Binding({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind,\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node: t.Identifier | t.JSXIdentifier) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name: string): boolean {\n    let scope: Scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while ((scope = scope.parent));\n\n    return false;\n  }\n\n  hasGlobal(name: string): boolean {\n    let scope: Scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while ((scope = scope.parent));\n\n    return false;\n  }\n\n  hasReference(name: string): boolean {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node: t.Node, constantsOnly?: boolean): boolean {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (\n      isThisExpression(node) ||\n      isMetaProperty(node) ||\n      isTopicReference(node) ||\n      isPrivateName(node)\n    ) {\n      return true;\n    } else if (isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n      if (node.decorators?.length > 0) {\n        return false;\n      }\n      return this.isPure(node.body, constantsOnly);\n    } else if (isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isBinary(node)) {\n      return (\n        this.isPure(node.left, constantsOnly) &&\n        this.isPure(node.right, constantsOnly)\n      );\n    } else if (isArrayExpression(node) || isTupleExpression(node)) {\n      for (const elem of node.elements) {\n        if (elem !== null && !this.isPure(elem, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isObjectExpression(node) || isRecordExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.decorators?.length > 0) {\n        return false;\n      }\n      return true;\n    } else if (isProperty(node)) {\n      // @ts-expect-error todo(flow->ts): computed in not present on private properties\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.decorators?.length > 0) {\n        return false;\n      }\n      if (isObjectProperty(node) || node.static) {\n        if (node.value !== null && !this.isPure(node.value, constantsOnly)) {\n          return false;\n        }\n      }\n      return true;\n    } else if (isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (isTaggedTemplateExpression(node)) {\n      return (\n        matchesPattern(node.tag, \"String.raw\") &&\n        !this.hasBinding(\"String\", true) &&\n        this.isPure(node.quasi, constantsOnly)\n      );\n    } else if (isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n      return true;\n    } else {\n      return isPureish(node);\n    }\n  }\n\n  /**\n   * Set some arbitrary data on the current scope.\n   */\n\n  setData(key: string | symbol, val: any) {\n    return (this.data[key] = val);\n  }\n\n  /**\n   * Recursively walk up scope tree looking for the data `key`.\n   */\n\n  getData(key: string | symbol): any {\n    let scope: Scope = this;\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while ((scope = scope.parent));\n  }\n\n  /**\n   * Recursively walk up scope tree looking for the data `key` and if it exists,\n   * remove it.\n   */\n\n  removeData(key: string) {\n    let scope: Scope = this;\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while ((scope = scope.parent));\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n\n    const state: CollectVisitorState = {\n      references: [],\n      constantViolations: [],\n      assignments: [],\n    };\n\n    this.crawling = true;\n    // traverse does not visit the root node, here we explicitly collect\n    // root node binding info when the root is not a Program.\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      // @ts-expect-error when collectorVisitor is exploded, `enter` always exists\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n      const typeVisitors = collectorVisitor[path.type];\n      if (typeVisitors) {\n        // @ts-expect-error when collectorVisitor is exploded, `enter` always exists\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    // register assignments\n    for (const path of state.assignments) {\n      // register undeclared bindings as globals\n      const ids = path.getBindingIdentifiers();\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      // register as constant violation\n      path.scope.registerConstantViolation(path);\n    }\n\n    // register references\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    // register constant violations\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts: {\n    id: t.LVal;\n    init?: t.Expression;\n    unique?: boolean;\n    _blockHoist?: number | undefined;\n    kind?: \"var\" | \"let\" | \"const\";\n  }) {\n    let path = this.path;\n\n    if (path.isPattern()) {\n      path = this.getPatternParent().path;\n    } else if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      // @ts-expect-error TS can not infer NodePath<Loop> | NodePath<CatchClause> as NodePath<Loop | CatchClause>\n      path.ensureBlock();\n      // @ts-expect-error todo(flow->ts): improve types\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = variableDeclaration(kind, []);\n      // @ts-expect-error todo(flow->ts): avoid modifying nodes\n      declar._blockHoist = blockHoist;\n\n      [declarPath] = (path as NodePath<t.BlockStatement>).unshiftContainer(\n        \"body\",\n        [declar],\n      );\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = variableDeclarator(opts.id, opts.init);\n    const len = declarPath.node.declarations.push(declarator);\n    path.scope.registerBinding(kind, declarPath.get(\"declarations\")[len - 1]);\n  }\n\n  /**\n   * Walk up to the top of the scope tree and get the `Program`.\n   */\n\n  getProgramParent() {\n    let scope: Scope = this;\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while ((scope = scope.parent));\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  /**\n   * Walk up the scope tree until we hit either a Function or return null.\n   */\n\n  getFunctionParent(): Scope | null {\n    let scope: Scope = this;\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while ((scope = scope.parent));\n    return null;\n  }\n\n  /**\n   * Walk up the scope tree until we hit either a BlockStatement/Loop/Program/Function/Switch or reach the\n   * very top and hit Program.\n   */\n\n  getBlockParent() {\n    let scope: Scope = this;\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while ((scope = scope.parent));\n    throw new Error(\n      \"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\",\n    );\n  }\n\n  /**\n   * Walk up from a pattern scope (function param initializer) until we hit a non-pattern scope,\n   * then returns its block parent\n   * @returns An ancestry scope whose path is a block parent\n   */\n  getPatternParent() {\n    let scope: Scope = this;\n    do {\n      if (!scope.path.isPattern()) {\n        return scope.getBlockParent();\n      }\n    } while ((scope = scope.parent.parent));\n    throw new Error(\n      \"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\",\n    );\n  }\n\n  /**\n   * Walks the scope tree and gathers **all** bindings.\n   */\n\n  getAllBindings(): Record<string, Binding> {\n    const ids = Object.create(null);\n\n    let scope: Scope = this;\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  /**\n   * Walks the scope tree and gathers all declarations of `kind`.\n   */\n\n  getAllBindingsOfKind(...kinds: string[]): Record<string, Binding> {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope: Scope = this;\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name: string, node: t.Node): boolean {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name: string): Binding | undefined {\n    let scope: Scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n      if (binding) {\n        // Check if a pattern is a part of parameter expressions.\n        // Note: for performance reason we skip checking previousPath.parentPath.isFunction()\n        // because `scope.path` is validated as scope in packages/babel-types/src/validators/isScope.js\n        // That is, if a scope path is pattern, its parent must be Function/CatchClause\n\n        // Spec 9.2.10.28: The closure created by this expression should not have visibility of\n        // declarations in the function body. If the binding is not a `param`-kind (as function parameters)\n        // or `local`-kind (as id in function expression),\n        // then it must be defined inside the function body, thus it should be skipped\n        if (\n          previousPath?.isPattern() &&\n          binding.kind !== \"param\" &&\n          binding.kind !== \"local\"\n        ) {\n          // do nothing\n        } else {\n          return binding;\n        }\n      } else if (\n        !binding &&\n        name === \"arguments\" &&\n        scope.path.isFunction() &&\n        !scope.path.isArrowFunctionExpression()\n      ) {\n        break;\n      }\n      previousPath = scope.path;\n    } while ((scope = scope.parent));\n  }\n\n  getOwnBinding(name: string): Binding | undefined {\n    return this.bindings[name];\n  }\n\n  // todo: return probably can be undefined…\n  getBindingIdentifier(name: string): t.Identifier {\n    return this.getBinding(name)?.identifier;\n  }\n\n  // todo: flow->ts return probably can be undefined\n  getOwnBindingIdentifier(name: string): t.Identifier {\n    const binding = this.bindings[name];\n    return binding?.identifier;\n  }\n\n  hasOwnBinding(name: string) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name: string, noGlobals?: boolean) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name: string, noGlobals?: boolean) {\n    return this.parent?.hasBinding(name, noGlobals);\n  }\n\n  /**\n   * Move a binding of `name` to another `scope`.\n   */\n\n  moveBindingTo(name: string, scope: Scope) {\n    const info = this.getBinding(name);\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name: string) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name: string) {\n    // clear literal binding\n    this.getBinding(name)?.scope.removeOwnBinding(name);\n\n    // clear uids with this name - https://github.com/babel/babel/issues/2101\n    let scope: Scope = this;\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while ((scope = scope.parent));\n  }\n}\n"],"mappings":"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"}
>>>>>>> main
