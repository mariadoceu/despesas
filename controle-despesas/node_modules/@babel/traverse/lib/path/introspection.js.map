<<<<<<< HEAD
{"version":3,"names":["STATEMENT_OR_BLOCK_KEYS","VISITOR_KEYS","isBlockStatement","isExpression","isIdentifier","isLiteral","isStringLiteral","isType","matchesPattern","_matchesPattern","pattern","allowPartial","node","has","key","val","Array","isArray","length","isStatic","scope","is","isnt","equals","value","isNodeType","type","canHaveVariableDeclarationOrExpression","parentPath","isFor","canSwapBetweenExpressionAndStatement","replacement","isArrowFunctionExpression","isCompletionRecord","allowInsideFunction","path","first","container","isFunction","isProgram","isDoExpression","isStatementOrBlock","isLabeledStatement","includes","referencesImport","moduleSource","importName","isReferencedIdentifier","isJSXMemberExpression","property","name","isMemberExpression","isOptionalMemberExpression","computed","object","get","binding","getBinding","kind","parent","isImportDeclaration","source","isImportDefaultSpecifier","isImportNamespaceSpecifier","isImportSpecifier","imported","getSource","end","code","hub","getCode","slice","start","willIMaybeExecuteBefore","target","_guessExecutionStatusRelativeTo","getOuterFunction","getFunctionParent","getProgramParent","isExecutionUncertain","isExecutionUncertainInList","paths","maxIndex","i","parentKey","_guessExecutionStatusRelativeToCached","Map","base","cache","funcParent","this","_guessExecutionStatusRelativeToDifferentFunctionsCached","getAncestry","indexOf","commonPath","commonIndex","Error","divergence","listKey","keys","keyPosition","executionOrderCheckedNodes","Set","_guessExecutionStatusRelativeToDifferentFunctionsInternal","isFunctionDeclaration","isExportDeclaration","id","references","referencePaths","allStatus","childOfFunction","find","isCallExpression","add","status","delete","nodeMap","set","result","resolve","dangerous","resolved","_resolve","push","isVariableDeclarator","constant","ret","isTypeCastExpression","targetKey","toComputedKey","targetName","isObjectExpression","props","prop","isProperty","match","isArrayExpression","isNaN","elems","elem","isConstantExpression","isRegExpLiteral","isTemplateLiteral","every","expression","isUnaryExpression","operator","isBinaryExpression","isInStrictMode","strictParent","sourceType","isClass","body","directive","directives"],"sources":["../../src/path/introspection.ts"],"sourcesContent":["// This file contains methods responsible for introspecting the current path for certain values.\n\nimport type NodePath from \"./index\";\nimport {\n  STATEMENT_OR_BLOCK_KEYS,\n  VISITOR_KEYS,\n  isBlockStatement,\n  isExpression,\n  isIdentifier,\n  isLiteral,\n  isStringLiteral,\n  isType,\n  matchesPattern as _matchesPattern,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n/**\n * Match the current node if it matches the provided `pattern`.\n *\n * For example, given the match `React.createClass` it would match the\n * parsed nodes of `React.createClass` and `React[\"createClass\"]`.\n */\n\nexport function matchesPattern(\n  this: NodePath,\n  pattern: string,\n  allowPartial?: boolean,\n): boolean {\n  return _matchesPattern(this.node, pattern, allowPartial);\n}\n\n/**\n * Check whether we have the input `key`. If the `key` references an array then we check\n * if the array has any items, otherwise we just check if it's falsy.\n */\n\nexport function has<N extends t.Node>(\n  this: NodePath<N>,\n  key: keyof N,\n): boolean {\n  const val = this.node && this.node[key];\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\n/**\n * Description\n */\n\nexport function isStatic(this: NodePath): boolean {\n  return this.scope.isStatic(this.node);\n}\n\n/**\n * Alias of `has`.\n */\n\nexport const is = has;\n\n/**\n * Opposite of `has`.\n */\n\nexport function isnt<N extends t.Node>(\n  this: NodePath<N>,\n  key: keyof N,\n): boolean {\n  return !this.has(key);\n}\n\n/**\n * Check whether the path node `key` strict equals `value`.\n */\n\nexport function equals<N extends t.Node>(\n  this: NodePath<N>,\n  key: keyof N,\n  value: any,\n): boolean {\n  return this.node[key] === value;\n}\n\n/**\n * Check the type against our stored internal type of the node. This is handy when a node has\n * been removed yet we still internally know the type and need it to calculate node replacement.\n */\n\nexport function isNodeType(this: NodePath, type: string): boolean {\n  return isType(this.type, type);\n}\n\n/**\n * This checks whether or not we're in one of the following positions:\n *\n *   for (KEY in right);\n *   for (KEY;;);\n *\n * This is because these spots allow VariableDeclarations AND normal expressions so we need\n * to tell the path replacement that it's ok to replace this with an expression.\n */\n\nexport function canHaveVariableDeclarationOrExpression(this: NodePath) {\n  return (\n    (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor()\n  );\n}\n\n/**\n * This checks whether we are swapping an arrow function's body between an\n * expression and a block statement (or vice versa).\n *\n * This is because arrow functions may implicitly return an expression, which\n * is the same as containing a block statement.\n */\n\nexport function canSwapBetweenExpressionAndStatement(\n  this: NodePath,\n  replacement: t.Node,\n): boolean {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return isExpression(replacement);\n  }\n\n  return false;\n}\n\n/**\n * Check whether the current path references a completion record\n */\n\nexport function isCompletionRecord(\n  this: NodePath,\n  allowInsideFunction?: boolean,\n): boolean {\n  let path = this;\n  let first = true;\n\n  do {\n    const { type, container } = path;\n\n    // we're in a function so can't be a completion record\n    if (!first && (path.isFunction() || type === \"StaticBlock\")) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    // check to see if we're the last item in the container and if we are\n    // we're a completion record!\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while (\n    (path = path.parentPath) &&\n    !path.isProgram() &&\n    !path.isDoExpression()\n  );\n\n  return true;\n}\n\n/**\n * Check whether or not the current `key` allows either a single statement or block statement\n * so we can explode it if necessary.\n */\n\nexport function isStatementOrBlock(this: NodePath): boolean {\n  if (\n    this.parentPath.isLabeledStatement() ||\n    isBlockStatement(this.container)\n  ) {\n    return false;\n  } else {\n    return STATEMENT_OR_BLOCK_KEYS.includes(this.key as string);\n  }\n}\n\n/**\n * Check if the currently assigned path references the `importName` of `moduleSource`.\n */\n\nexport function referencesImport(\n  this: NodePath,\n  moduleSource: string,\n  importName: string,\n): boolean {\n  if (!this.isReferencedIdentifier()) {\n    if (\n      (this.isJSXMemberExpression() &&\n        this.node.property.name === importName) ||\n      ((this.isMemberExpression() || this.isOptionalMemberExpression()) &&\n        (this.node.computed\n          ? isStringLiteral(this.node.property, { value: importName })\n          : (this.node.property as t.Identifier).name === importName))\n    ) {\n      const object = (\n        this as NodePath<t.MemberExpression | t.OptionalMemberExpression>\n      ).get(\"object\");\n      return (\n        object.isReferencedIdentifier() &&\n        object.referencesImport(moduleSource, \"*\")\n      );\n    }\n\n    return false;\n  }\n\n  const binding = this.scope.getBinding((this.node as t.Identifier).name);\n  if (!binding || binding.kind !== \"module\") return false;\n\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  // check moduleSource\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (\n    path.isImportSpecifier() &&\n    isIdentifier(path.node.imported, { name: importName })\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Get the source code associated with this node.\n */\n\nexport function getSource(this: NodePath): string {\n  const node = this.node;\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n  return \"\";\n}\n\nexport function willIMaybeExecuteBefore(\n  this: NodePath,\n  target: NodePath,\n): boolean {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\nfunction getOuterFunction(path: NodePath) {\n  return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;\n}\n\nfunction isExecutionUncertain(type: t.Node[\"type\"], key: string) {\n  switch (type) {\n    // a && FOO\n    // a || FOO\n    case \"LogicalExpression\":\n      return key === \"right\";\n\n    // a ? FOO : FOO\n    // if (a) FOO; else FOO;\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      return key === \"consequent\" || key === \"alternate\";\n\n    // while (a) FOO;\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      return key === \"body\";\n\n    // for (a; b; FOO) FOO;\n    case \"ForStatement\":\n      return key === \"body\" || key === \"update\";\n\n    // switch (a) { FOO }\n    case \"SwitchStatement\":\n      return key === \"cases\";\n\n    // try { a } catch FOO finally { b }\n    case \"TryStatement\":\n      return key === \"handler\";\n\n    // var [ x = FOO ]\n    case \"AssignmentPattern\":\n      return key === \"right\";\n\n    // a?.[FOO]\n    case \"OptionalMemberExpression\":\n      return key === \"property\";\n\n    // a?.(FOO)\n    case \"OptionalCallExpression\":\n      return key === \"arguments\";\n\n    default:\n      return false;\n  }\n}\n\nfunction isExecutionUncertainInList(paths: NodePath[], maxIndex: number) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// TODO (Babel 8)\n// This can be { before: boolean, after: boolean, unknown: boolean }.\n// This allows transforms like the tdz one to treat cases when the status\n// is both before and unknown/after like if it were before.\ntype RelativeExecutionStatus = \"before\" | \"after\" | \"unknown\";\n\ntype ExecutionStatusCache = Map<t.Node, Map<t.Node, RelativeExecutionStatus>>;\n\n/**\n * Given a `target` check the execution status of it relative to the current path.\n *\n * \"Execution status\" simply refers to where or not we **think** this will execute\n * before or after the input `target` element.\n */\n\nexport function _guessExecutionStatusRelativeTo(\n  this: NodePath,\n  target: NodePath,\n): RelativeExecutionStatus {\n  return _guessExecutionStatusRelativeToCached(this, target, new Map());\n}\n\nfunction _guessExecutionStatusRelativeToCached(\n  base: NodePath,\n  target: NodePath,\n  cache: ExecutionStatusCache,\n): RelativeExecutionStatus {\n  // check if the two paths are in different functions, we can't track execution of these\n  const funcParent = {\n    this: getOuterFunction(base),\n    target: getOuterFunction(target),\n  };\n\n  // here we check the `node` equality as sometimes we may have different paths for the\n  // same node due to path thrashing\n  if (funcParent.target.node !== funcParent.this.node) {\n    return _guessExecutionStatusRelativeToDifferentFunctionsCached(\n      base,\n      funcParent.target,\n      cache,\n    );\n  }\n\n  const paths = {\n    target: target.getAncestry(),\n    this: base.getAncestry(),\n  };\n\n  // If this is an ancestor of the target path,\n  // e.g. f(g); where this is f and target is g.\n  if (paths.target.indexOf(base) >= 0) return \"after\";\n  if (paths.this.indexOf(target) >= 0) return \"before\";\n\n  // get ancestor where the branches intersect\n  let commonPath;\n  const commonIndex = { target: 0, this: 0 };\n\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n\n  if (!commonPath) {\n    throw new Error(\n      \"Internal Babel error - The two compared nodes\" +\n        \" don't appear to belong to the same program.\",\n    );\n  }\n\n  if (\n    isExecutionUncertainInList(paths.this, commonIndex.this - 1) ||\n    isExecutionUncertainInList(paths.target, commonIndex.target - 1)\n  ) {\n    return \"unknown\";\n  }\n\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1],\n  };\n\n  // container list so let's see which one is after the other\n  // e.g. [ THIS, TARGET ]\n  if (\n    divergence.target.listKey &&\n    divergence.this.listKey &&\n    divergence.target.container === divergence.this.container\n  ) {\n    return divergence.target.key > divergence.this.key ? \"before\" : \"after\";\n  }\n\n  // otherwise we're associated by a parent node, check which key comes before the other\n  const keys = VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey as string),\n    target: keys.indexOf(divergence.target.parentKey as string),\n  };\n  return keyPosition.target > keyPosition.this ? \"before\" : \"after\";\n}\n\n// Used to avoid infinite recursion in cases like\n//   function f() { if (false) f(); }\n//   f();\n// It also works with indirect recursion.\nconst executionOrderCheckedNodes = new Set();\n\nfunction _guessExecutionStatusRelativeToDifferentFunctionsInternal(\n  base: NodePath,\n  target: NodePath,\n  cache: ExecutionStatusCache,\n): RelativeExecutionStatus {\n  if (\n    !target.isFunctionDeclaration() ||\n    target.parentPath.isExportDeclaration()\n  ) {\n    return \"unknown\";\n  }\n\n  // so we're in a completely different function, if this is a function declaration\n  // then we can be a bit smarter and handle cases where the function is either\n  // a. not called at all (part of an export)\n  // b. called directly\n  const binding = target.scope.getBinding(target.node.id.name);\n\n  // no references!\n  if (!binding.references) return \"before\";\n\n  const referencePaths: Array<NodePath> = binding.referencePaths;\n\n  let allStatus;\n\n  // verify that all the calls have the same execution status\n  for (const path of referencePaths) {\n    // if a reference is a child of the function we're checking against then we can\n    // safely ignore it\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      // This function is passed as a reference, so we don't\n      // know when it will be called.\n      return \"unknown\";\n    }\n\n    // Prevent infinite loops in recursive functions\n    if (executionOrderCheckedNodes.has(path.node)) continue;\n    executionOrderCheckedNodes.add(path.node);\n    try {\n      const status = _guessExecutionStatusRelativeToCached(base, path, cache);\n\n      if (allStatus && allStatus !== status) {\n        return \"unknown\";\n      } else {\n        allStatus = status;\n      }\n    } finally {\n      executionOrderCheckedNodes.delete(path.node);\n    }\n  }\n\n  return allStatus;\n}\n\nfunction _guessExecutionStatusRelativeToDifferentFunctionsCached(\n  base: NodePath,\n  target: NodePath,\n  cache: ExecutionStatusCache,\n): RelativeExecutionStatus {\n  let nodeMap = cache.get(base.node);\n  if (!nodeMap) {\n    cache.set(base.node, (nodeMap = new Map()));\n  } else if (nodeMap.has(target.node)) {\n    return nodeMap.get(target.node);\n  }\n\n  const result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(\n    base,\n    target,\n    cache,\n  );\n\n  nodeMap.set(target.node, result);\n  return result;\n}\n\n/**\n * Resolve a \"pointer\" `NodePath` to it's absolute path.\n */\nexport function resolve(\n  this: NodePath,\n  dangerous?: boolean,\n  resolved?: NodePath[],\n) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\nexport function _resolve(\n  this: NodePath,\n  dangerous?: boolean,\n  resolved?: NodePath[],\n): NodePath | undefined | null {\n  // detect infinite recursion\n  // todo: possibly have a max length on this just to be safe\n  if (resolved && resolved.indexOf(this) >= 0) return;\n\n  // we store all the paths we've \"resolved\" in this array to prevent infinite recursion\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {\n      // otherwise it's a request for a pattern and that's a bit more tricky\n    }\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n\n    // reassigned so we can't really resolve it\n    if (!binding.constant) return;\n\n    // todo - lookup module in dependency graph\n    if (binding.kind === \"module\") return;\n\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      // If the identifier resolves to parent node then we can't really resolve it.\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    // @ ts-ignore todo: babel-types\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    // this is dangerous, as non-direct target assignments will mutate it's state\n    // making this resolution inaccurate\n\n    const targetKey = this.toComputedKey();\n    if (!isLiteral(targetKey)) return;\n\n    // @ts-expect-error todo(flow->ts): NullLiteral\n    const targetName = targetKey.value;\n\n    const target = this.get(\"object\").resolve(dangerous, resolved);\n\n    if (target.isObjectExpression()) {\n      const props = target.get(\"properties\");\n      for (const prop of props as any[]) {\n        if (!prop.isProperty()) continue;\n\n        const key = prop.get(\"key\");\n\n        // { foo: obj }\n        let match =\n          prop.isnt(\"computed\") && key.isIdentifier({ name: targetName });\n\n        // { \"foo\": \"obj\" } or { [\"foo\"]: \"obj\" }\n        match = match || key.isLiteral({ value: targetName });\n\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get(\"elements\");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\n\nexport function isConstantExpression(this: NodePath): boolean {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n\n    if (this.isTemplateLiteral()) {\n      return this.get(\"expressions\").every(expression =>\n        expression.isConstantExpression(),\n      );\n    }\n\n    return true;\n  }\n\n  if (this.isUnaryExpression()) {\n    if (this.node.operator !== \"void\") {\n      return false;\n    }\n\n    return this.get(\"argument\").isConstantExpression();\n  }\n\n  if (this.isBinaryExpression()) {\n    const { operator } = this.node;\n    return (\n      operator !== \"in\" &&\n      operator !== \"instanceof\" &&\n      this.get(\"left\").isConstantExpression() &&\n      this.get(\"right\").isConstantExpression()\n    );\n  }\n\n  return false;\n}\n\nexport function isInStrictMode(this: NodePath) {\n  const start = this.isProgram() ? this : this.parentPath;\n\n  const strictParent = start.find(path => {\n    if (path.isProgram({ sourceType: \"module\" })) return true;\n\n    if (path.isClass()) return true;\n\n    if (\n      path.isArrowFunctionExpression() &&\n      !path.get(\"body\").isBlockStatement()\n    ) {\n      return false;\n    }\n\n    let body: t.BlockStatement | t.Program;\n    if (path.isFunction()) {\n      body = path.node.body as t.BlockStatement;\n    } else if (path.isProgram()) {\n      body = path.node;\n    } else {\n      return false;\n    }\n\n    for (const directive of body.directives) {\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  });\n\n  return !!strictParent;\n}\n"],"mappings":"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"}
=======
{"version":3,"names":["STATEMENT_OR_BLOCK_KEYS","VISITOR_KEYS","isBlockStatement","isExpression","isIdentifier","isLiteral","isStringLiteral","isType","matchesPattern","_matchesPattern","pattern","allowPartial","node","has","key","val","Array","isArray","length","isStatic","scope","is","isnt","equals","value","isNodeType","type","canHaveVariableDeclarationOrExpression","parentPath","isFor","canSwapBetweenExpressionAndStatement","replacement","isArrowFunctionExpression","isCompletionRecord","allowInsideFunction","path","first","container","isFunction","isProgram","isDoExpression","isStatementOrBlock","isLabeledStatement","includes","referencesImport","moduleSource","importName","isReferencedIdentifier","isJSXMemberExpression","property","name","isMemberExpression","isOptionalMemberExpression","computed","object","get","binding","getBinding","kind","parent","isImportDeclaration","source","isImportDefaultSpecifier","isImportNamespaceSpecifier","isImportSpecifier","imported","getSource","end","code","hub","getCode","slice","start","willIMaybeExecuteBefore","target","_guessExecutionStatusRelativeTo","getOuterFunction","getFunctionParent","getProgramParent","isExecutionUncertain","isExecutionUncertainInList","paths","maxIndex","i","parentKey","_guessExecutionStatusRelativeToCached","Map","base","cache","funcParent","this","_guessExecutionStatusRelativeToDifferentFunctionsCached","getAncestry","indexOf","commonPath","commonIndex","Error","divergence","listKey","keys","keyPosition","executionOrderCheckedNodes","Set","_guessExecutionStatusRelativeToDifferentFunctionsInternal","isFunctionDeclaration","isExportDeclaration","id","references","referencePaths","allStatus","childOfFunction","find","isCallExpression","add","status","delete","nodeMap","set","result","resolve","dangerous","resolved","_resolve","push","isVariableDeclarator","constant","ret","isTypeCastExpression","targetKey","toComputedKey","targetName","isObjectExpression","props","prop","isProperty","match","isArrayExpression","isNaN","elems","elem","isConstantExpression","isRegExpLiteral","isTemplateLiteral","every","expression","isUnaryExpression","operator","isBinaryExpression","isInStrictMode","strictParent","sourceType","isClass","body","directive","directives"],"sources":["../../src/path/introspection.ts"],"sourcesContent":["// This file contains methods responsible for introspecting the current path for certain values.\n\nimport type NodePath from \"./index\";\nimport {\n  STATEMENT_OR_BLOCK_KEYS,\n  VISITOR_KEYS,\n  isBlockStatement,\n  isExpression,\n  isIdentifier,\n  isLiteral,\n  isStringLiteral,\n  isType,\n  matchesPattern as _matchesPattern,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n/**\n * Match the current node if it matches the provided `pattern`.\n *\n * For example, given the match `React.createClass` it would match the\n * parsed nodes of `React.createClass` and `React[\"createClass\"]`.\n */\n\nexport function matchesPattern(\n  this: NodePath,\n  pattern: string,\n  allowPartial?: boolean,\n): boolean {\n  return _matchesPattern(this.node, pattern, allowPartial);\n}\n\n/**\n * Check whether we have the input `key`. If the `key` references an array then we check\n * if the array has any items, otherwise we just check if it's falsy.\n */\n\nexport function has<N extends t.Node>(\n  this: NodePath<N>,\n  key: keyof N,\n): boolean {\n  const val = this.node && this.node[key];\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\n/**\n * Description\n */\n\nexport function isStatic(this: NodePath): boolean {\n  return this.scope.isStatic(this.node);\n}\n\n/**\n * Alias of `has`.\n */\n\nexport const is = has;\n\n/**\n * Opposite of `has`.\n */\n\nexport function isnt<N extends t.Node>(\n  this: NodePath<N>,\n  key: keyof N,\n): boolean {\n  return !this.has(key);\n}\n\n/**\n * Check whether the path node `key` strict equals `value`.\n */\n\nexport function equals<N extends t.Node>(\n  this: NodePath<N>,\n  key: keyof N,\n  value: any,\n): boolean {\n  return this.node[key] === value;\n}\n\n/**\n * Check the type against our stored internal type of the node. This is handy when a node has\n * been removed yet we still internally know the type and need it to calculate node replacement.\n */\n\nexport function isNodeType(this: NodePath, type: string): boolean {\n  return isType(this.type, type);\n}\n\n/**\n * This checks whether or not we're in one of the following positions:\n *\n *   for (KEY in right);\n *   for (KEY;;);\n *\n * This is because these spots allow VariableDeclarations AND normal expressions so we need\n * to tell the path replacement that it's ok to replace this with an expression.\n */\n\nexport function canHaveVariableDeclarationOrExpression(this: NodePath) {\n  return (\n    (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor()\n  );\n}\n\n/**\n * This checks whether we are swapping an arrow function's body between an\n * expression and a block statement (or vice versa).\n *\n * This is because arrow functions may implicitly return an expression, which\n * is the same as containing a block statement.\n */\n\nexport function canSwapBetweenExpressionAndStatement(\n  this: NodePath,\n  replacement: t.Node,\n): boolean {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return isExpression(replacement);\n  }\n\n  return false;\n}\n\n/**\n * Check whether the current path references a completion record\n */\n\nexport function isCompletionRecord(\n  this: NodePath,\n  allowInsideFunction?: boolean,\n): boolean {\n  let path = this;\n  let first = true;\n\n  do {\n    const { type, container } = path;\n\n    // we're in a function so can't be a completion record\n    if (!first && (path.isFunction() || type === \"StaticBlock\")) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    // check to see if we're the last item in the container and if we are\n    // we're a completion record!\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while (\n    (path = path.parentPath) &&\n    !path.isProgram() &&\n    !path.isDoExpression()\n  );\n\n  return true;\n}\n\n/**\n * Check whether or not the current `key` allows either a single statement or block statement\n * so we can explode it if necessary.\n */\n\nexport function isStatementOrBlock(this: NodePath): boolean {\n  if (\n    this.parentPath.isLabeledStatement() ||\n    isBlockStatement(this.container)\n  ) {\n    return false;\n  } else {\n    return STATEMENT_OR_BLOCK_KEYS.includes(this.key as string);\n  }\n}\n\n/**\n * Check if the currently assigned path references the `importName` of `moduleSource`.\n */\n\nexport function referencesImport(\n  this: NodePath,\n  moduleSource: string,\n  importName: string,\n): boolean {\n  if (!this.isReferencedIdentifier()) {\n    if (\n      (this.isJSXMemberExpression() &&\n        this.node.property.name === importName) ||\n      ((this.isMemberExpression() || this.isOptionalMemberExpression()) &&\n        (this.node.computed\n          ? isStringLiteral(this.node.property, { value: importName })\n          : (this.node.property as t.Identifier).name === importName))\n    ) {\n      const object = (\n        this as NodePath<t.MemberExpression | t.OptionalMemberExpression>\n      ).get(\"object\");\n      return (\n        object.isReferencedIdentifier() &&\n        object.referencesImport(moduleSource, \"*\")\n      );\n    }\n\n    return false;\n  }\n\n  const binding = this.scope.getBinding((this.node as t.Identifier).name);\n  if (!binding || binding.kind !== \"module\") return false;\n\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  // check moduleSource\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (\n    path.isImportSpecifier() &&\n    isIdentifier(path.node.imported, { name: importName })\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Get the source code associated with this node.\n */\n\nexport function getSource(this: NodePath): string {\n  const node = this.node;\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n  return \"\";\n}\n\nexport function willIMaybeExecuteBefore(\n  this: NodePath,\n  target: NodePath,\n): boolean {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\nfunction getOuterFunction(path: NodePath) {\n  return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;\n}\n\nfunction isExecutionUncertain(type: t.Node[\"type\"], key: string) {\n  switch (type) {\n    // a && FOO\n    // a || FOO\n    case \"LogicalExpression\":\n      return key === \"right\";\n\n    // a ? FOO : FOO\n    // if (a) FOO; else FOO;\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      return key === \"consequent\" || key === \"alternate\";\n\n    // while (a) FOO;\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      return key === \"body\";\n\n    // for (a; b; FOO) FOO;\n    case \"ForStatement\":\n      return key === \"body\" || key === \"update\";\n\n    // switch (a) { FOO }\n    case \"SwitchStatement\":\n      return key === \"cases\";\n\n    // try { a } catch FOO finally { b }\n    case \"TryStatement\":\n      return key === \"handler\";\n\n    // var [ x = FOO ]\n    case \"AssignmentPattern\":\n      return key === \"right\";\n\n    // a?.[FOO]\n    case \"OptionalMemberExpression\":\n      return key === \"property\";\n\n    // a?.(FOO)\n    case \"OptionalCallExpression\":\n      return key === \"arguments\";\n\n    default:\n      return false;\n  }\n}\n\nfunction isExecutionUncertainInList(paths: NodePath[], maxIndex: number) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// TODO (Babel 8)\n// This can be { before: boolean, after: boolean, unknown: boolean }.\n// This allows transforms like the tdz one to treat cases when the status\n// is both before and unknown/after like if it were before.\ntype RelativeExecutionStatus = \"before\" | \"after\" | \"unknown\";\n\ntype ExecutionStatusCache = Map<t.Node, Map<t.Node, RelativeExecutionStatus>>;\n\n/**\n * Given a `target` check the execution status of it relative to the current path.\n *\n * \"Execution status\" simply refers to where or not we **think** this will execute\n * before or after the input `target` element.\n */\n\nexport function _guessExecutionStatusRelativeTo(\n  this: NodePath,\n  target: NodePath,\n): RelativeExecutionStatus {\n  return _guessExecutionStatusRelativeToCached(this, target, new Map());\n}\n\nfunction _guessExecutionStatusRelativeToCached(\n  base: NodePath,\n  target: NodePath,\n  cache: ExecutionStatusCache,\n): RelativeExecutionStatus {\n  // check if the two paths are in different functions, we can't track execution of these\n  const funcParent = {\n    this: getOuterFunction(base),\n    target: getOuterFunction(target),\n  };\n\n  // here we check the `node` equality as sometimes we may have different paths for the\n  // same node due to path thrashing\n  if (funcParent.target.node !== funcParent.this.node) {\n    return _guessExecutionStatusRelativeToDifferentFunctionsCached(\n      base,\n      funcParent.target,\n      cache,\n    );\n  }\n\n  const paths = {\n    target: target.getAncestry(),\n    this: base.getAncestry(),\n  };\n\n  // If this is an ancestor of the target path,\n  // e.g. f(g); where this is f and target is g.\n  if (paths.target.indexOf(base) >= 0) return \"after\";\n  if (paths.this.indexOf(target) >= 0) return \"before\";\n\n  // get ancestor where the branches intersect\n  let commonPath;\n  const commonIndex = { target: 0, this: 0 };\n\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n\n  if (!commonPath) {\n    throw new Error(\n      \"Internal Babel error - The two compared nodes\" +\n        \" don't appear to belong to the same program.\",\n    );\n  }\n\n  if (\n    isExecutionUncertainInList(paths.this, commonIndex.this - 1) ||\n    isExecutionUncertainInList(paths.target, commonIndex.target - 1)\n  ) {\n    return \"unknown\";\n  }\n\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1],\n  };\n\n  // container list so let's see which one is after the other\n  // e.g. [ THIS, TARGET ]\n  if (\n    divergence.target.listKey &&\n    divergence.this.listKey &&\n    divergence.target.container === divergence.this.container\n  ) {\n    return divergence.target.key > divergence.this.key ? \"before\" : \"after\";\n  }\n\n  // otherwise we're associated by a parent node, check which key comes before the other\n  const keys = VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey as string),\n    target: keys.indexOf(divergence.target.parentKey as string),\n  };\n  return keyPosition.target > keyPosition.this ? \"before\" : \"after\";\n}\n\n// Used to avoid infinite recursion in cases like\n//   function f() { if (false) f(); }\n//   f();\n// It also works with indirect recursion.\nconst executionOrderCheckedNodes = new Set();\n\nfunction _guessExecutionStatusRelativeToDifferentFunctionsInternal(\n  base: NodePath,\n  target: NodePath,\n  cache: ExecutionStatusCache,\n): RelativeExecutionStatus {\n  if (\n    !target.isFunctionDeclaration() ||\n    target.parentPath.isExportDeclaration()\n  ) {\n    return \"unknown\";\n  }\n\n  // so we're in a completely different function, if this is a function declaration\n  // then we can be a bit smarter and handle cases where the function is either\n  // a. not called at all (part of an export)\n  // b. called directly\n  const binding = target.scope.getBinding(target.node.id.name);\n\n  // no references!\n  if (!binding.references) return \"before\";\n\n  const referencePaths: Array<NodePath> = binding.referencePaths;\n\n  let allStatus;\n\n  // verify that all the calls have the same execution status\n  for (const path of referencePaths) {\n    // if a reference is a child of the function we're checking against then we can\n    // safely ignore it\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      // This function is passed as a reference, so we don't\n      // know when it will be called.\n      return \"unknown\";\n    }\n\n    // Prevent infinite loops in recursive functions\n    if (executionOrderCheckedNodes.has(path.node)) continue;\n    executionOrderCheckedNodes.add(path.node);\n    try {\n      const status = _guessExecutionStatusRelativeToCached(base, path, cache);\n\n      if (allStatus && allStatus !== status) {\n        return \"unknown\";\n      } else {\n        allStatus = status;\n      }\n    } finally {\n      executionOrderCheckedNodes.delete(path.node);\n    }\n  }\n\n  return allStatus;\n}\n\nfunction _guessExecutionStatusRelativeToDifferentFunctionsCached(\n  base: NodePath,\n  target: NodePath,\n  cache: ExecutionStatusCache,\n): RelativeExecutionStatus {\n  let nodeMap = cache.get(base.node);\n  if (!nodeMap) {\n    cache.set(base.node, (nodeMap = new Map()));\n  } else if (nodeMap.has(target.node)) {\n    return nodeMap.get(target.node);\n  }\n\n  const result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(\n    base,\n    target,\n    cache,\n  );\n\n  nodeMap.set(target.node, result);\n  return result;\n}\n\n/**\n * Resolve a \"pointer\" `NodePath` to it's absolute path.\n */\nexport function resolve(\n  this: NodePath,\n  dangerous?: boolean,\n  resolved?: NodePath[],\n) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\nexport function _resolve(\n  this: NodePath,\n  dangerous?: boolean,\n  resolved?: NodePath[],\n): NodePath | undefined | null {\n  // detect infinite recursion\n  // todo: possibly have a max length on this just to be safe\n  if (resolved && resolved.indexOf(this) >= 0) return;\n\n  // we store all the paths we've \"resolved\" in this array to prevent infinite recursion\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {\n      // otherwise it's a request for a pattern and that's a bit more tricky\n    }\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n\n    // reassigned so we can't really resolve it\n    if (!binding.constant) return;\n\n    // todo - lookup module in dependency graph\n    if (binding.kind === \"module\") return;\n\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      // If the identifier resolves to parent node then we can't really resolve it.\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    // @ ts-ignore todo: babel-types\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    // this is dangerous, as non-direct target assignments will mutate it's state\n    // making this resolution inaccurate\n\n    const targetKey = this.toComputedKey();\n    if (!isLiteral(targetKey)) return;\n\n    // @ts-expect-error todo(flow->ts): NullLiteral\n    const targetName = targetKey.value;\n\n    const target = this.get(\"object\").resolve(dangerous, resolved);\n\n    if (target.isObjectExpression()) {\n      const props = target.get(\"properties\");\n      for (const prop of props as any[]) {\n        if (!prop.isProperty()) continue;\n\n        const key = prop.get(\"key\");\n\n        // { foo: obj }\n        let match =\n          prop.isnt(\"computed\") && key.isIdentifier({ name: targetName });\n\n        // { \"foo\": \"obj\" } or { [\"foo\"]: \"obj\" }\n        match = match || key.isLiteral({ value: targetName });\n\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get(\"elements\");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\n\nexport function isConstantExpression(this: NodePath): boolean {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n\n    if (this.isTemplateLiteral()) {\n      return this.get(\"expressions\").every(expression =>\n        expression.isConstantExpression(),\n      );\n    }\n\n    return true;\n  }\n\n  if (this.isUnaryExpression()) {\n    if (this.node.operator !== \"void\") {\n      return false;\n    }\n\n    return this.get(\"argument\").isConstantExpression();\n  }\n\n  if (this.isBinaryExpression()) {\n    return (\n      this.get(\"left\").isConstantExpression() &&\n      this.get(\"right\").isConstantExpression()\n    );\n  }\n\n  return false;\n}\n\nexport function isInStrictMode(this: NodePath) {\n  const start = this.isProgram() ? this : this.parentPath;\n\n  const strictParent = start.find(path => {\n    if (path.isProgram({ sourceType: \"module\" })) return true;\n\n    if (path.isClass()) return true;\n\n    if (\n      path.isArrowFunctionExpression() &&\n      !path.get(\"body\").isBlockStatement()\n    ) {\n      return false;\n    }\n\n    let body: t.BlockStatement | t.Program;\n    if (path.isFunction()) {\n      body = path.node.body as t.BlockStatement;\n    } else if (path.isProgram()) {\n      body = path.node;\n    } else {\n      return false;\n    }\n\n    for (const directive of body.directives) {\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  });\n\n  return !!strictParent;\n}\n"],"mappings":"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"}
>>>>>>> main
