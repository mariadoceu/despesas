"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.evaluate = evaluate;
exports.evaluateTruthy = evaluateTruthy;
<<<<<<< HEAD

const VALID_CALLEES = ["String", "Number", "Math"];
const INVALID_METHODS = ["random"];
function isValidCallee(val) {
  return VALID_CALLEES.includes(
  val);
}
function isInvalidMethod(val) {
  return INVALID_METHODS.includes(
  val);
=======
const VALID_CALLEES = ["String", "Number", "Math"];
const INVALID_METHODS = ["random"];

function isValidCallee(val) {
  return VALID_CALLEES.includes(val);
}

function isInvalidMethod(val) {
  return INVALID_METHODS.includes(val);
>>>>>>> main
}

function evaluateTruthy() {
  const res = this.evaluate();
  if (res.confident) return !!res.value;
}
<<<<<<< HEAD
=======

>>>>>>> main
function deopt(path, state) {
  if (!state.confident) return;
  state.deoptPath = path;
  state.confident = false;
}

function evaluateCached(path, state) {
  const {
    node
  } = path;
  const {
    seen
  } = state;
<<<<<<< HEAD
  if (seen.has(node)) {
    const existing = seen.get(node);
=======

  if (seen.has(node)) {
    const existing = seen.get(node);

>>>>>>> main
    if (existing.resolved) {
      return existing.value;
    } else {
      deopt(path, state);
      return;
    }
  } else {
    const item = {
      resolved: false
    };
    seen.set(node, item);
<<<<<<< HEAD
    const val = _evaluate(path, state);
=======

    const val = _evaluate(path, state);

>>>>>>> main
    if (state.confident) {
      item.resolved = true;
      item.value = val;
    }
<<<<<<< HEAD
    return val;
  }
}
function _evaluate(path, state) {
  if (!state.confident) return;
=======

    return val;
  }
}

function _evaluate(path, state) {
  if (!state.confident) return;

>>>>>>> main
  if (path.isSequenceExpression()) {
    const exprs = path.get("expressions");
    return evaluateCached(exprs[exprs.length - 1], state);
  }
<<<<<<< HEAD
  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
    return path.node.value;
  }
  if (path.isNullLiteral()) {
    return null;
  }
  if (path.isTemplateLiteral()) {
    return evaluateQuasis(path, path.node.quasis, state);
  }
=======

  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
    return path.node.value;
  }

  if (path.isNullLiteral()) {
    return null;
  }

  if (path.isTemplateLiteral()) {
    return evaluateQuasis(path, path.node.quasis, state);
  }

>>>>>>> main
  if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {
    const object = path.get("tag.object");
    const {
      node: {
        name
      }
    } = object;
    const property = path.get("tag.property");
<<<<<<< HEAD
    if (object.isIdentifier() && name === "String" &&
    !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === "raw") {
      return evaluateQuasis(path, path.node.quasi.quasis, state, true);
    }
  }
  if (path.isConditionalExpression()) {
    const testResult = evaluateCached(path.get("test"), state);
    if (!state.confident) return;
=======

    if (object.isIdentifier() && name === "String" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === "raw") {
      return evaluateQuasis(path, path.node.quasi.quasis, state, true);
    }
  }

  if (path.isConditionalExpression()) {
    const testResult = evaluateCached(path.get("test"), state);
    if (!state.confident) return;

>>>>>>> main
    if (testResult) {
      return evaluateCached(path.get("consequent"), state);
    } else {
      return evaluateCached(path.get("alternate"), state);
    }
  }
<<<<<<< HEAD
=======

>>>>>>> main
  if (path.isExpressionWrapper()) {
    return evaluateCached(path.get("expression"), state);
  }

  if (path.isMemberExpression() && !path.parentPath.isCallExpression({
    callee: path.node
  })) {
    const property = path.get("property");
    const object = path.get("object");
<<<<<<< HEAD
    if (object.isLiteral() && property.isIdentifier()) {
      const value = object.node.value;
      const type = typeof value;
=======

    if (object.isLiteral() && property.isIdentifier()) {
      const value = object.node.value;
      const type = typeof value;

>>>>>>> main
      if (type === "number" || type === "string") {
        return value[property.node.name];
      }
    }
  }
<<<<<<< HEAD
  if (path.isReferencedIdentifier()) {
    const binding = path.scope.getBinding(path.node.name);
    if (binding && binding.constantViolations.length > 0) {
      return deopt(binding.path, state);
    }
    if (binding && path.node.start < binding.path.node.end) {
      return deopt(binding.path, state);
    }
=======

  if (path.isReferencedIdentifier()) {
    const binding = path.scope.getBinding(path.node.name);

    if (binding && binding.constantViolations.length > 0) {
      return deopt(binding.path, state);
    }

    if (binding && path.node.start < binding.path.node.end) {
      return deopt(binding.path, state);
    }

>>>>>>> main
    if (binding != null && binding.hasValue) {
      return binding.value;
    } else {
      if (path.node.name === "undefined") {
        return binding ? deopt(binding.path, state) : undefined;
      } else if (path.node.name === "Infinity") {
        return binding ? deopt(binding.path, state) : Infinity;
      } else if (path.node.name === "NaN") {
        return binding ? deopt(binding.path, state) : NaN;
      }
<<<<<<< HEAD
      const resolved = path.resolve();
=======

      const resolved = path.resolve();

>>>>>>> main
      if (resolved === path) {
        return deopt(path, state);
      } else {
        return evaluateCached(resolved, state);
      }
    }
  }
<<<<<<< HEAD
=======

>>>>>>> main
  if (path.isUnaryExpression({
    prefix: true
  })) {
    if (path.node.operator === "void") {
      return undefined;
    }
<<<<<<< HEAD
    const argument = path.get("argument");
    if (path.node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
      return "function";
    }
    const arg = evaluateCached(argument, state);
    if (!state.confident) return;
    switch (path.node.operator) {
      case "!":
        return !arg;
      case "+":
        return +arg;
      case "-":
        return -arg;
      case "~":
        return ~arg;
=======

    const argument = path.get("argument");

    if (path.node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
      return "function";
    }

    const arg = evaluateCached(argument, state);
    if (!state.confident) return;

    switch (path.node.operator) {
      case "!":
        return !arg;

      case "+":
        return +arg;

      case "-":
        return -arg;

      case "~":
        return ~arg;

>>>>>>> main
      case "typeof":
        return typeof arg;
    }
  }
<<<<<<< HEAD
  if (path.isArrayExpression()) {
    const arr = [];
    const elems = path.get("elements");
    for (const elem of elems) {
      const elemValue = elem.evaluate();
=======

  if (path.isArrayExpression()) {
    const arr = [];
    const elems = path.get("elements");

    for (const elem of elems) {
      const elemValue = elem.evaluate();

>>>>>>> main
      if (elemValue.confident) {
        arr.push(elemValue.value);
      } else {
        return deopt(elemValue.deopt, state);
      }
    }
<<<<<<< HEAD
    return arr;
  }
  if (path.isObjectExpression()) {
    const obj = {};
    const props = path.get("properties");
=======

    return arr;
  }

  if (path.isObjectExpression()) {
    const obj = {};
    const props = path.get("properties");

>>>>>>> main
    for (const prop of props) {
      if (prop.isObjectMethod() || prop.isSpreadElement()) {
        return deopt(prop, state);
      }
<<<<<<< HEAD
      const keyPath = prop.get("key");
      let key;
      if (prop.node.computed) {
        key = keyPath.evaluate();
        if (!key.confident) {
          return deopt(key.deopt, state);
        }
=======

      const keyPath = prop.get("key");
      let key;

      if (prop.node.computed) {
        key = keyPath.evaluate();

        if (!key.confident) {
          return deopt(key.deopt, state);
        }

>>>>>>> main
        key = key.value;
      } else if (keyPath.isIdentifier()) {
        key = keyPath.node.name;
      } else {
        key = keyPath.node.value;
      }
<<<<<<< HEAD
      const valuePath = prop.get("value");
      let value = valuePath.evaluate();
      if (!value.confident) {
        return deopt(value.deopt, state);
      }
      value = value.value;
      obj[key] = value;
    }
    return obj;
  }
=======

      const valuePath = prop.get("value");
      let value = valuePath.evaluate();

      if (!value.confident) {
        return deopt(value.deopt, state);
      }

      value = value.value;
      obj[key] = value;
    }

    return obj;
  }

>>>>>>> main
  if (path.isLogicalExpression()) {
    const wasConfident = state.confident;
    const left = evaluateCached(path.get("left"), state);
    const leftConfident = state.confident;
    state.confident = wasConfident;
    const right = evaluateCached(path.get("right"), state);
    const rightConfident = state.confident;
<<<<<<< HEAD
=======

>>>>>>> main
    switch (path.node.operator) {
      case "||":
        state.confident = leftConfident && (!!left || rightConfident);
        if (!state.confident) return;
        return left || right;
<<<<<<< HEAD
=======

>>>>>>> main
      case "&&":
        state.confident = leftConfident && (!left || rightConfident);
        if (!state.confident) return;
        return left && right;
<<<<<<< HEAD
=======

>>>>>>> main
      case "??":
        state.confident = leftConfident && (left != null || rightConfident);
        if (!state.confident) return;
        return left != null ? left : right;
    }
  }
<<<<<<< HEAD
=======

>>>>>>> main
  if (path.isBinaryExpression()) {
    const left = evaluateCached(path.get("left"), state);
    if (!state.confident) return;
    const right = evaluateCached(path.get("right"), state);
    if (!state.confident) return;
<<<<<<< HEAD
    switch (path.node.operator) {
      case "-":
        return left - right;
      case "+":
        return left + right;
      case "/":
        return left / right;
      case "*":
        return left * right;
      case "%":
        return left % right;
      case "**":
        return Math.pow(left, right);
      case "<":
        return left < right;
      case ">":
        return left > right;
      case "<=":
        return left <= right;
      case ">=":
        return left >= right;
      case "==":
        return left == right;
      case "!=":
        return left != right;
      case "===":
        return left === right;
      case "!==":
        return left !== right;
      case "|":
        return left | right;
      case "&":
        return left & right;
      case "^":
        return left ^ right;
      case "<<":
        return left << right;
      case ">>":
        return left >> right;
=======

    switch (path.node.operator) {
      case "-":
        return left - right;

      case "+":
        return left + right;

      case "/":
        return left / right;

      case "*":
        return left * right;

      case "%":
        return left % right;

      case "**":
        return Math.pow(left, right);

      case "<":
        return left < right;

      case ">":
        return left > right;

      case "<=":
        return left <= right;

      case ">=":
        return left >= right;

      case "==":
        return left == right;

      case "!=":
        return left != right;

      case "===":
        return left === right;

      case "!==":
        return left !== right;

      case "|":
        return left | right;

      case "&":
        return left & right;

      case "^":
        return left ^ right;

      case "<<":
        return left << right;

      case ">>":
        return left >> right;

>>>>>>> main
      case ">>>":
        return left >>> right;
    }
  }
<<<<<<< HEAD
=======

>>>>>>> main
  if (path.isCallExpression()) {
    const callee = path.get("callee");
    let context;
    let func;

    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && isValidCallee(callee.node.name)) {
      func = global[callee.node.name];
    }
<<<<<<< HEAD
=======

>>>>>>> main
    if (callee.isMemberExpression()) {
      const object = callee.get("object");
      const property = callee.get("property");

      if (object.isIdentifier() && property.isIdentifier() && isValidCallee(object.node.name) && !isInvalidMethod(property.node.name)) {
        context = global[object.node.name];
        func = context[property.node.name];
      }

      if (object.isLiteral() && property.isIdentifier()) {
        const type = typeof object.node.value;
<<<<<<< HEAD
=======

>>>>>>> main
        if (type === "string" || type === "number") {
          context = object.node.value;
          func = context[property.node.name];
        }
      }
    }
<<<<<<< HEAD
=======

>>>>>>> main
    if (func) {
      const args = path.get("arguments").map(arg => evaluateCached(arg, state));
      if (!state.confident) return;
      return func.apply(context, args);
    }
  }
<<<<<<< HEAD
  deopt(path, state);
}
=======

  deopt(path, state);
}

>>>>>>> main
function evaluateQuasis(path, quasis, state, raw = false) {
  let str = "";
  let i = 0;
  const exprs = path.get("expressions");
<<<<<<< HEAD
  for (const elem of quasis) {
    if (!state.confident) break;

    str += raw ? elem.value.raw : elem.value.cooked;

    const expr = exprs[i++];
    if (expr) str += String(evaluateCached(expr, state));
  }
=======

  for (const elem of quasis) {
    if (!state.confident) break;
    str += raw ? elem.value.raw : elem.value.cooked;
    const expr = exprs[i++];
    if (expr) str += String(evaluateCached(expr, state));
  }

>>>>>>> main
  if (!state.confident) return;
  return str;
}

function evaluate() {
  const state = {
    confident: true,
    deoptPath: null,
    seen: new Map()
  };
  let value = evaluateCached(this, state);
  if (!state.confident) value = undefined;
  return {
    confident: state.confident,
    deopt: state.deoptPath,
    value: value
  };
}

//# sourceMappingURL=evaluation.js.map
