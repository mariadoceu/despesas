<<<<<<< HEAD
{"version":3,"names":["BOOLEAN_BINARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","NUMBER_BINARY_OPERATORS","NUMBER_UNARY_OPERATORS","STRING_UNARY_OPERATORS","anyTypeAnnotation","arrayTypeAnnotation","booleanTypeAnnotation","buildMatchMemberExpression","genericTypeAnnotation","identifier","nullLiteralTypeAnnotation","numberTypeAnnotation","stringTypeAnnotation","tupleTypeAnnotation","unionTypeAnnotation","voidTypeAnnotation","isIdentifier","VariableDeclarator","get","getTypeAnnotation","TypeCastExpression","node","typeAnnotation","validParent","TSAsExpression","TSNonNullExpression","NewExpression","callee","type","TemplateLiteral","UnaryExpression","operator","indexOf","BinaryExpression","right","left","isBaseType","LogicalExpression","argumentTypes","createUnionType","ConditionalExpression","SequenceExpression","pop","ParenthesizedExpression","AssignmentExpression","UpdateExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","RegExpLiteral","ObjectExpression","ArrayExpression","RestElement","Func","isArrayFrom","isObjectKeys","isObjectValues","isObjectEntries","CallExpression","name","resolveCall","TaggedTemplateExpression","resolve","isFunction","async","generator","returnType"],"sources":["../../../src/path/inference/inferers.ts"],"sourcesContent":["import {\n  BOOLEAN_BINARY_OPERATORS,\n  BOOLEAN_UNARY_OPERATORS,\n  NUMBER_BINARY_OPERATORS,\n  NUMBER_UNARY_OPERATORS,\n  STRING_UNARY_OPERATORS,\n  anyTypeAnnotation,\n  arrayTypeAnnotation,\n  booleanTypeAnnotation,\n  buildMatchMemberExpression,\n  genericTypeAnnotation,\n  identifier,\n  nullLiteralTypeAnnotation,\n  numberTypeAnnotation,\n  stringTypeAnnotation,\n  tupleTypeAnnotation,\n  unionTypeAnnotation,\n  voidTypeAnnotation,\n  isIdentifier,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nexport { default as Identifier } from \"./inferer-reference\";\n\nimport { createUnionType } from \"./util\";\nimport type NodePath from \"..\";\n\nexport function VariableDeclarator(this: NodePath<t.VariableDeclarator>) {\n  if (!this.get(\"id\").isIdentifier()) return;\n  return this.get(\"init\").getTypeAnnotation();\n}\n\nexport function TypeCastExpression(node: t.TypeCastExpression) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nexport function TSAsExpression(node: t.TSAsExpression) {\n  return node.typeAnnotation;\n}\n\nTSAsExpression.validParent = true;\n\nexport function TSNonNullExpression(this: NodePath<t.TSNonNullExpression>) {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nexport function NewExpression(\n  this: NodePath<t.NewExpression>,\n  node: t.NewExpression,\n) {\n  if (node.callee.type === \"Identifier\") {\n    // only resolve identifier callee\n    return genericTypeAnnotation(node.callee);\n  }\n}\n\nexport function TemplateLiteral() {\n  return stringTypeAnnotation();\n}\n\nexport function UnaryExpression(node: t.UnaryExpression) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return voidTypeAnnotation();\n  } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return stringTypeAnnotation();\n  } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  }\n}\n\nexport function BinaryExpression(\n  this: NodePath<t.BinaryExpression>,\n  node: t.BinaryExpression,\n) {\n  const operator = node.operator;\n\n  if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      // both numbers so this will be a number\n      return numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      // one is a string so the result will be a string\n      return stringTypeAnnotation();\n    }\n\n    // unsure if left and right are strings or numbers so stay on the safe side\n    return unionTypeAnnotation([\n      stringTypeAnnotation(),\n      numberTypeAnnotation(),\n    ]);\n  }\n}\n\nexport function LogicalExpression(this: NodePath<t.LogicalExpression>) {\n  const argumentTypes = [\n    this.get(\"left\").getTypeAnnotation(),\n    this.get(\"right\").getTypeAnnotation(),\n  ];\n\n  return createUnionType(argumentTypes);\n}\n\nexport function ConditionalExpression(this: NodePath<t.ConditionalExpression>) {\n  const argumentTypes = [\n    this.get(\"consequent\").getTypeAnnotation(),\n    this.get(\"alternate\").getTypeAnnotation(),\n  ];\n\n  return createUnionType(argumentTypes);\n}\n\nexport function SequenceExpression(this: NodePath<t.SequenceExpression>) {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nexport function ParenthesizedExpression(\n  this: NodePath<t.ParenthesizedExpression>,\n) {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nexport function AssignmentExpression(this: NodePath<t.AssignmentExpression>) {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nexport function UpdateExpression(\n  this: NodePath<t.UpdateExpression>,\n  node: t.UpdateExpression,\n) {\n  const operator = node.operator;\n  if (operator === \"++\" || operator === \"--\") {\n    return numberTypeAnnotation();\n  }\n}\n\nexport function StringLiteral() {\n  return stringTypeAnnotation();\n}\n\nexport function NumericLiteral() {\n  return numberTypeAnnotation();\n}\n\nexport function BooleanLiteral() {\n  return booleanTypeAnnotation();\n}\n\nexport function NullLiteral() {\n  return nullLiteralTypeAnnotation();\n}\n\nexport function RegExpLiteral() {\n  return genericTypeAnnotation(identifier(\"RegExp\"));\n}\n\nexport function ObjectExpression() {\n  return genericTypeAnnotation(identifier(\"Object\"));\n}\n\nexport function ArrayExpression() {\n  return genericTypeAnnotation(identifier(\"Array\"));\n}\n\nexport function RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return genericTypeAnnotation(identifier(\"Function\"));\n}\n\nexport {\n  Func as FunctionExpression,\n  Func as ArrowFunctionExpression,\n  Func as FunctionDeclaration,\n  Func as ClassExpression,\n  Func as ClassDeclaration,\n};\n\nconst isArrayFrom = buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = buildMatchMemberExpression(\"Object.entries\");\nexport function CallExpression(this: NodePath<t.CallExpression>) {\n  const { callee } = this.node;\n  if (isObjectKeys(callee)) {\n    return arrayTypeAnnotation(stringTypeAnnotation());\n  } else if (\n    isArrayFrom(callee) ||\n    isObjectValues(callee) ||\n    // Detect \"var foo = Array()\" calls so we can optimize for arrays vs iterables.\n    isIdentifier(callee, { name: \"Array\" })\n  ) {\n    return arrayTypeAnnotation(anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return arrayTypeAnnotation(\n      tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]),\n    );\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nexport function TaggedTemplateExpression(\n  this: NodePath<t.TaggedTemplateExpression>,\n) {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee: NodePath) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    const { node } = callee;\n    if (node.async) {\n      if (node.generator) {\n        return genericTypeAnnotation(identifier(\"AsyncIterator\"));\n      } else {\n        return genericTypeAnnotation(identifier(\"Promise\"));\n      }\n    } else {\n      if (node.generator) {\n        return genericTypeAnnotation(identifier(\"Iterator\"));\n      } else if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {\n        // todo: get union type of all return arguments\n      }\n    }\n  }\n}\n"],"mappings":"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"}
=======
{"version":3,"names":["BOOLEAN_BINARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","NUMBER_BINARY_OPERATORS","NUMBER_UNARY_OPERATORS","STRING_UNARY_OPERATORS","anyTypeAnnotation","arrayTypeAnnotation","booleanTypeAnnotation","buildMatchMemberExpression","genericTypeAnnotation","identifier","nullLiteralTypeAnnotation","numberTypeAnnotation","stringTypeAnnotation","tupleTypeAnnotation","unionTypeAnnotation","voidTypeAnnotation","isIdentifier","VariableDeclarator","get","getTypeAnnotation","TypeCastExpression","node","typeAnnotation","validParent","TSAsExpression","TSNonNullExpression","NewExpression","callee","type","TemplateLiteral","UnaryExpression","operator","indexOf","BinaryExpression","right","left","isBaseType","LogicalExpression","argumentTypes","createUnionType","ConditionalExpression","SequenceExpression","pop","ParenthesizedExpression","AssignmentExpression","UpdateExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","RegExpLiteral","ObjectExpression","ArrayExpression","RestElement","Func","isArrayFrom","isObjectKeys","isObjectValues","isObjectEntries","CallExpression","name","resolveCall","TaggedTemplateExpression","resolve","isFunction","async","generator","returnType"],"sources":["../../../src/path/inference/inferers.ts"],"sourcesContent":["import {\n  BOOLEAN_BINARY_OPERATORS,\n  BOOLEAN_UNARY_OPERATORS,\n  NUMBER_BINARY_OPERATORS,\n  NUMBER_UNARY_OPERATORS,\n  STRING_UNARY_OPERATORS,\n  anyTypeAnnotation,\n  arrayTypeAnnotation,\n  booleanTypeAnnotation,\n  buildMatchMemberExpression,\n  genericTypeAnnotation,\n  identifier,\n  nullLiteralTypeAnnotation,\n  numberTypeAnnotation,\n  stringTypeAnnotation,\n  tupleTypeAnnotation,\n  unionTypeAnnotation,\n  voidTypeAnnotation,\n  isIdentifier,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nexport { default as Identifier } from \"./inferer-reference\";\n\nimport { createUnionType } from \"./util\";\nimport type NodePath from \"..\";\n\nexport function VariableDeclarator(this: NodePath<t.VariableDeclarator>) {\n  if (!this.get(\"id\").isIdentifier()) return;\n  return this.get(\"init\").getTypeAnnotation();\n}\n\nexport function TypeCastExpression(node: t.TypeCastExpression) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nexport function TSAsExpression(node: t.TSAsExpression) {\n  return node.typeAnnotation;\n}\n\nTSAsExpression.validParent = true;\n\nexport function TSNonNullExpression(this: NodePath<t.TSNonNullExpression>) {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nexport function NewExpression(\n  this: NodePath<t.NewExpression>,\n  node: t.NewExpression,\n) {\n  if (node.callee.type === \"Identifier\") {\n    // only resolve identifier callee\n    return genericTypeAnnotation(node.callee);\n  }\n}\n\nexport function TemplateLiteral() {\n  return stringTypeAnnotation();\n}\n\nexport function UnaryExpression(node: t.UnaryExpression) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return voidTypeAnnotation();\n  } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return stringTypeAnnotation();\n  } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  }\n}\n\nexport function BinaryExpression(\n  this: NodePath<t.BinaryExpression>,\n  node: t.BinaryExpression,\n) {\n  const operator = node.operator;\n\n  if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      // both numbers so this will be a number\n      return numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      // one is a string so the result will be a string\n      return stringTypeAnnotation();\n    }\n\n    // unsure if left and right are strings or numbers so stay on the safe side\n    return unionTypeAnnotation([\n      stringTypeAnnotation(),\n      numberTypeAnnotation(),\n    ]);\n  }\n}\n\nexport function LogicalExpression(this: NodePath<t.LogicalExpression>) {\n  const argumentTypes = [\n    this.get(\"left\").getTypeAnnotation(),\n    this.get(\"right\").getTypeAnnotation(),\n  ];\n\n  return createUnionType(argumentTypes);\n}\n\nexport function ConditionalExpression(this: NodePath<t.ConditionalExpression>) {\n  const argumentTypes = [\n    this.get(\"consequent\").getTypeAnnotation(),\n    this.get(\"alternate\").getTypeAnnotation(),\n  ];\n\n  return createUnionType(argumentTypes);\n}\n\nexport function SequenceExpression(this: NodePath<t.SequenceExpression>) {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nexport function ParenthesizedExpression(\n  this: NodePath<t.ParenthesizedExpression>,\n) {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nexport function AssignmentExpression(this: NodePath<t.AssignmentExpression>) {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nexport function UpdateExpression(\n  this: NodePath<t.UpdateExpression>,\n  node: t.UpdateExpression,\n) {\n  const operator = node.operator;\n  if (operator === \"++\" || operator === \"--\") {\n    return numberTypeAnnotation();\n  }\n}\n\nexport function StringLiteral() {\n  return stringTypeAnnotation();\n}\n\nexport function NumericLiteral() {\n  return numberTypeAnnotation();\n}\n\nexport function BooleanLiteral() {\n  return booleanTypeAnnotation();\n}\n\nexport function NullLiteral() {\n  return nullLiteralTypeAnnotation();\n}\n\nexport function RegExpLiteral() {\n  return genericTypeAnnotation(identifier(\"RegExp\"));\n}\n\nexport function ObjectExpression() {\n  return genericTypeAnnotation(identifier(\"Object\"));\n}\n\nexport function ArrayExpression() {\n  return genericTypeAnnotation(identifier(\"Array\"));\n}\n\nexport function RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return genericTypeAnnotation(identifier(\"Function\"));\n}\n\nexport {\n  Func as FunctionExpression,\n  Func as ArrowFunctionExpression,\n  Func as FunctionDeclaration,\n  Func as ClassExpression,\n  Func as ClassDeclaration,\n};\n\nconst isArrayFrom = buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = buildMatchMemberExpression(\"Object.entries\");\nexport function CallExpression(this: NodePath<t.CallExpression>) {\n  const { callee } = this.node;\n  if (isObjectKeys(callee)) {\n    return arrayTypeAnnotation(stringTypeAnnotation());\n  } else if (\n    isArrayFrom(callee) ||\n    isObjectValues(callee) ||\n    // Detect \"var foo = Array()\" calls so we can optimize for arrays vs iterables.\n    isIdentifier(callee, { name: \"Array\" })\n  ) {\n    return arrayTypeAnnotation(anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return arrayTypeAnnotation(\n      tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]),\n    );\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nexport function TaggedTemplateExpression(\n  this: NodePath<t.TaggedTemplateExpression>,\n) {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee: NodePath) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    const { node } = callee;\n    if (node.async) {\n      if (node.generator) {\n        return genericTypeAnnotation(identifier(\"AsyncIterator\"));\n      } else {\n        return genericTypeAnnotation(identifier(\"Promise\"));\n      }\n    } else {\n      if (node.generator) {\n        return genericTypeAnnotation(identifier(\"Iterator\"));\n      } else if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {\n        // todo: get union type of all return arguments\n      }\n    }\n  }\n}\n"],"mappings":"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"}
>>>>>>> main
