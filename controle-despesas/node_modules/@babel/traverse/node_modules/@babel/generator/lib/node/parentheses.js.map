<<<<<<< HEAD
{"version":3,"names":["isArrayTypeAnnotation","isArrowFunctionExpression","isAssignmentExpression","isAwaitExpression","isBinary","isBinaryExpression","isUpdateExpression","isCallExpression","isClass","isClassExpression","isConditional","isConditionalExpression","isExportDeclaration","isExportDefaultDeclaration","isExpressionStatement","isFor","isForInStatement","isForOfStatement","isForStatement","isFunctionExpression","isIfStatement","isIndexedAccessType","isIntersectionTypeAnnotation","isLogicalExpression","isMemberExpression","isNewExpression","isNullableTypeAnnotation","isObjectPattern","isOptionalCallExpression","isOptionalMemberExpression","isReturnStatement","isSequenceExpression","isSwitchStatement","isTSArrayType","isTSAsExpression","isTSInstantiationExpression","isTSIntersectionType","isTSNonNullExpression","isTSOptionalType","isTSRestType","isTSTypeAssertion","isTSUnionType","isTaggedTemplateExpression","isThrowStatement","isTypeAnnotation","isUnaryLike","isUnionTypeAnnotation","isVariableDeclarator","isWhileStatement","isYieldExpression","isTSSatisfiesExpression","PRECEDENCE","in","instanceof","isClassExtendsClause","node","parent","superClass","hasPostfixPart","object","callee","tag","NullableTypeAnnotation","FunctionTypeAnnotation","printStack","length","UpdateExpression","ObjectExpression","isFirstInContext","DoExpression","async","Binary","operator","left","parentOp","parentPos","nodeOp","nodePos","right","UnionTypeAnnotation","OptionalIndexedAccessType","objectType","TSAsExpression","TSUnionType","TSInferType","TSInstantiationExpression","typeParameters","BinaryExpression","SequenceExpression","test","discriminant","expression","YieldExpression","ClassExpression","UnaryLike","FunctionExpression","ArrowFunctionExpression","ConditionalExpression","OptionalMemberExpression","AssignmentExpression","LogicalExpression","Identifier","extra","parenthesized","id","name","isFollowedByBracket","computed","optional","checkParam","expressionStatement","arrowBody","exportDefault","forHead","forInHead","forOfHead","i","declaration","body","init","expressions","prefix"],"sources":["../../src/node/parentheses.ts"],"sourcesContent":["import {\n  isArrayTypeAnnotation,\n  isArrowFunctionExpression,\n  isAssignmentExpression,\n  isAwaitExpression,\n  isBinary,\n  isBinaryExpression,\n  isUpdateExpression,\n  isCallExpression,\n  isClass,\n  isClassExpression,\n  isConditional,\n  isConditionalExpression,\n  isExportDeclaration,\n  isExportDefaultDeclaration,\n  isExpressionStatement,\n  isFor,\n  isForInStatement,\n  isForOfStatement,\n  isForStatement,\n  isFunctionExpression,\n  isIfStatement,\n  isIndexedAccessType,\n  isIntersectionTypeAnnotation,\n  isLogicalExpression,\n  isMemberExpression,\n  isNewExpression,\n  isNullableTypeAnnotation,\n  isObjectPattern,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isReturnStatement,\n  isSequenceExpression,\n  isSwitchStatement,\n  isTSArrayType,\n  isTSAsExpression,\n  isTSInstantiationExpression,\n  isTSIntersectionType,\n  isTSNonNullExpression,\n  isTSOptionalType,\n  isTSRestType,\n  isTSTypeAssertion,\n  isTSUnionType,\n  isTaggedTemplateExpression,\n  isThrowStatement,\n  isTypeAnnotation,\n  isUnaryLike,\n  isUnionTypeAnnotation,\n  isVariableDeclarator,\n  isWhileStatement,\n  isYieldExpression,\n  isTSSatisfiesExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"??\": 0,\n  \"|>\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10,\n};\n\nconst enum CheckParam {\n  expressionStatement = 1 << 0,\n  arrowBody = 1 << 1,\n  exportDefault = 1 << 2,\n  forHead = 1 << 3,\n  forInHead = 1 << 4,\n  forOfHead = 1 << 5,\n}\n\nconst isClassExtendsClause = (\n  node: t.Node,\n  parent: t.Node,\n): parent is t.Class => isClass(parent, { superClass: node });\n\nconst hasPostfixPart = (node: t.Node, parent: t.Node) =>\n  ((isMemberExpression(parent) || isOptionalMemberExpression(parent)) &&\n    parent.object === node) ||\n  ((isCallExpression(parent) ||\n    isOptionalCallExpression(parent) ||\n    isNewExpression(parent)) &&\n    parent.callee === node) ||\n  (isTaggedTemplateExpression(parent) && parent.tag === node) ||\n  isTSNonNullExpression(parent);\n\nexport function NullableTypeAnnotation(\n  node: t.NullableTypeAnnotation,\n  parent: t.Node,\n): boolean {\n  return isArrayTypeAnnotation(parent);\n}\n\nexport function FunctionTypeAnnotation(\n  node: t.FunctionTypeAnnotation,\n  parent: t.Node,\n  printStack: Array<t.Node>,\n): boolean {\n  if (printStack.length < 3) return;\n\n  return (\n    // (() => A) | (() => B)\n    isUnionTypeAnnotation(parent) ||\n    // (() => A) & (() => B)\n    isIntersectionTypeAnnotation(parent) ||\n    // (() => A)[]\n    isArrayTypeAnnotation(parent) ||\n    // <T>(A: T): (T => T[]) => B => [A, B]\n    (isTypeAnnotation(parent) &&\n      // Check grandparent\n      isArrowFunctionExpression(printStack[printStack.length - 3]))\n  );\n}\n\nexport function UpdateExpression(\n  node: t.UpdateExpression,\n  parent: t.Node,\n): boolean {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\n\nexport function ObjectExpression(\n  node: t.ObjectExpression,\n  parent: t.Node,\n  printStack: Array<t.Node>,\n): boolean {\n  return isFirstInContext(\n    printStack,\n    CheckParam.expressionStatement | CheckParam.arrowBody,\n  );\n}\n\nexport function DoExpression(\n  node: t.DoExpression,\n  parent: t.Node,\n  printStack: Array<t.Node>,\n): boolean {\n  // `async do` can start an expression statement\n  return (\n    !node.async && isFirstInContext(printStack, CheckParam.expressionStatement)\n  );\n}\n\nexport function Binary(node: t.BinaryExpression, parent: t.Node): boolean {\n  if (\n    node.operator === \"**\" &&\n    isBinaryExpression(parent, { operator: \"**\" })\n  ) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if (\n    hasPostfixPart(node, parent) ||\n    isUnaryLike(parent) ||\n    isAwaitExpression(parent)\n  ) {\n    return true;\n  }\n\n  if (isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n\n    if (\n      // Logical expressions with the same precedence don't need parens.\n      (parentPos === nodePos &&\n        parent.right === node &&\n        !isLogicalExpression(parent)) ||\n      parentPos > nodePos\n    ) {\n      return true;\n    }\n  }\n}\n\nexport function UnionTypeAnnotation(\n  node: t.UnionTypeAnnotation,\n  parent: t.Node,\n): boolean {\n  return (\n    isArrayTypeAnnotation(parent) ||\n    isNullableTypeAnnotation(parent) ||\n    isIntersectionTypeAnnotation(parent) ||\n    isUnionTypeAnnotation(parent)\n  );\n}\n\nexport { UnionTypeAnnotation as IntersectionTypeAnnotation };\n\nexport function OptionalIndexedAccessType(\n  node: t.OptionalIndexedAccessType,\n  parent: t.Node,\n): boolean {\n  return isIndexedAccessType(parent, { objectType: node });\n}\n\nexport function TSAsExpression() {\n  return true;\n}\n\nexport {\n  TSAsExpression as TSSatisfiesExpression,\n  TSAsExpression as TSTypeAssertion,\n};\n\nexport function TSUnionType(node: t.TSUnionType, parent: t.Node): boolean {\n  return (\n    isTSArrayType(parent) ||\n    isTSOptionalType(parent) ||\n    isTSIntersectionType(parent) ||\n    isTSUnionType(parent) ||\n    isTSRestType(parent)\n  );\n}\n\nexport { TSUnionType as TSIntersectionType };\n\nexport function TSInferType(node: t.TSInferType, parent: t.Node): boolean {\n  return isTSArrayType(parent) || isTSOptionalType(parent);\n}\n\nexport function TSInstantiationExpression(\n  node: t.TSInstantiationExpression,\n  parent: t.Node,\n) {\n  return (\n    (isCallExpression(parent) ||\n      isOptionalCallExpression(parent) ||\n      isNewExpression(parent) ||\n      isTSInstantiationExpression(parent)) &&\n    !!parent.typeParameters\n  );\n}\n\nexport function BinaryExpression(\n  node: t.BinaryExpression,\n  parent: t.Node,\n): boolean {\n  // let i = (1 in []);\n  // for ((1 in []);;);\n  return (\n    node.operator === \"in\" && (isVariableDeclarator(parent) || isFor(parent))\n  );\n}\n\nexport function SequenceExpression(\n  node: t.SequenceExpression,\n  parent: t.Node,\n): boolean {\n  if (\n    // Although parentheses wouldn\"t hurt around sequence\n    // expressions in the head of for loops, traditional style\n    // dictates that e.g. i++, j++ should not be wrapped with\n    // parentheses.\n    isForStatement(parent) ||\n    isThrowStatement(parent) ||\n    isReturnStatement(parent) ||\n    (isIfStatement(parent) && parent.test === node) ||\n    (isWhileStatement(parent) && parent.test === node) ||\n    (isForInStatement(parent) && parent.right === node) ||\n    (isSwitchStatement(parent) && parent.discriminant === node) ||\n    (isExpressionStatement(parent) && parent.expression === node)\n  ) {\n    return false;\n  }\n\n  // Otherwise err on the side of overparenthesization, adding\n  // explicit exceptions above if this proves overzealous.\n  return true;\n}\n\nexport function YieldExpression(\n  node: t.YieldExpression,\n  parent: t.Node,\n): boolean {\n  return (\n    isBinary(parent) ||\n    isUnaryLike(parent) ||\n    hasPostfixPart(node, parent) ||\n    (isAwaitExpression(parent) && isYieldExpression(node)) ||\n    (isConditionalExpression(parent) && node === parent.test) ||\n    isClassExtendsClause(node, parent)\n  );\n}\n\nexport { YieldExpression as AwaitExpression };\n\nexport function ClassExpression(\n  node: t.ClassExpression,\n  parent: t.Node,\n  printStack: Array<t.Node>,\n): boolean {\n  return isFirstInContext(\n    printStack,\n    CheckParam.expressionStatement | CheckParam.exportDefault,\n  );\n}\n\nexport function UnaryLike(\n  node:\n    | t.UnaryLike\n    | t.ArrowFunctionExpression\n    | t.ConditionalExpression\n    | t.AssignmentExpression,\n  parent: t.Node,\n): boolean {\n  return (\n    hasPostfixPart(node, parent) ||\n    isBinaryExpression(parent, { operator: \"**\", left: node }) ||\n    isClassExtendsClause(node, parent)\n  );\n}\n\nexport function FunctionExpression(\n  node: t.FunctionExpression,\n  parent: t.Node,\n  printStack: Array<t.Node>,\n): boolean {\n  return isFirstInContext(\n    printStack,\n    CheckParam.expressionStatement | CheckParam.exportDefault,\n  );\n}\n\nexport function ArrowFunctionExpression(\n  node: t.ArrowFunctionExpression,\n  parent: t.Node,\n): boolean {\n  return isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nexport function ConditionalExpression(\n  node:\n    | t.ConditionalExpression\n    | t.ArrowFunctionExpression\n    | t.AssignmentExpression,\n  parent?: t.Node,\n): boolean {\n  if (\n    isUnaryLike(parent) ||\n    isBinary(parent) ||\n    isConditionalExpression(parent, { test: node }) ||\n    isAwaitExpression(parent) ||\n    isTSTypeAssertion(parent) ||\n    isTSAsExpression(parent) ||\n    isTSSatisfiesExpression(parent)\n  ) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nexport function OptionalMemberExpression(\n  node: t.OptionalMemberExpression,\n  parent: t.Node,\n): boolean {\n  return (\n    isCallExpression(parent, { callee: node }) ||\n    isMemberExpression(parent, { object: node })\n  );\n}\n\nexport { OptionalMemberExpression as OptionalCallExpression };\n\nexport function AssignmentExpression(\n  node: t.AssignmentExpression,\n  parent: t.Node,\n): boolean {\n  if (isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\n\nexport function LogicalExpression(\n  node: t.LogicalExpression,\n  parent: t.Node,\n): boolean {\n  switch (node.operator) {\n    case \"||\":\n      if (!isLogicalExpression(parent)) return false;\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n    case \"&&\":\n      return isLogicalExpression(parent, { operator: \"??\" });\n    case \"??\":\n      return isLogicalExpression(parent) && parent.operator !== \"??\";\n  }\n}\n\nexport function Identifier(\n  node: t.Identifier,\n  parent: t.Node,\n  printStack: Array<t.Node>,\n): boolean {\n  // 13.15.2 AssignmentExpression RS: Evaluation\n  // (fn) = function () {};\n  if (\n    node.extra?.parenthesized &&\n    isAssignmentExpression(parent, { left: node }) &&\n    (isFunctionExpression(parent.right) || isClassExpression(parent.right)) &&\n    parent.right.id == null\n  ) {\n    return true;\n  }\n  // Non-strict code allows the identifier `let`, but it cannot occur as-is in\n  // certain contexts to avoid ambiguity with contextual keyword `let`.\n  if (node.name === \"let\") {\n    // Some contexts only forbid `let [`, so check if the next token would\n    // be the left bracket of a computed member expression.\n    const isFollowedByBracket =\n      isMemberExpression(parent, {\n        object: node,\n        computed: true,\n      }) ||\n      isOptionalMemberExpression(parent, {\n        object: node,\n        computed: true,\n        optional: false,\n      });\n    return isFirstInContext(\n      printStack,\n      isFollowedByBracket\n        ? CheckParam.expressionStatement |\n            CheckParam.forHead |\n            CheckParam.forInHead |\n            CheckParam.forOfHead\n        : CheckParam.forOfHead,\n    );\n  }\n\n  // ECMAScript specifically forbids a for-of loop from starting with the\n  // token sequence `for (async of`, because it would be ambiguous with\n  // `for (async of => {};;)`, so we need to add extra parentheses.\n  //\n  // If the parent is a for-await-of loop (i.e. parent.await === true), the\n  // parentheses aren't strictly needed, but we add them anyway because\n  // some tools (including earlier Babel versions) can't parse\n  // `for await (async of [])` without them.\n  return (\n    node.name === \"async\" && isForOfStatement(parent) && node === parent.left\n  );\n}\n\n// Walk up the print stack to determine if our node can come first\n// in a particular context.\nfunction isFirstInContext(\n  printStack: Array<t.Node>,\n  checkParam: CheckParam,\n): boolean {\n  const expressionStatement = checkParam & CheckParam.expressionStatement;\n  const arrowBody = checkParam & CheckParam.arrowBody;\n  const exportDefault = checkParam & CheckParam.exportDefault;\n  const forHead = checkParam & CheckParam.forHead;\n  const forInHead = checkParam & CheckParam.forInHead;\n  const forOfHead = checkParam & CheckParam.forOfHead;\n\n  let i = printStack.length - 1;\n  if (i <= 0) return;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n  while (i >= 0) {\n    if (\n      (expressionStatement &&\n        isExpressionStatement(parent, { expression: node })) ||\n      (exportDefault &&\n        isExportDefaultDeclaration(parent, { declaration: node })) ||\n      (arrowBody && isArrowFunctionExpression(parent, { body: node })) ||\n      (forHead && isForStatement(parent, { init: node })) ||\n      (forInHead && isForInStatement(parent, { left: node })) ||\n      (forOfHead && isForOfStatement(parent, { left: node }))\n    ) {\n      return true;\n    }\n\n    if (\n      i > 0 &&\n      ((hasPostfixPart(node, parent) && !isNewExpression(parent)) ||\n        (isSequenceExpression(parent) && parent.expressions[0] === node) ||\n        (isUpdateExpression(parent) && !parent.prefix) ||\n        isConditional(parent, { test: node }) ||\n        isBinary(parent, { left: node }) ||\n        isAssignmentExpression(parent, { left: node }))\n    ) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}\n"],"mappings":"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"}
=======
{"version":3,"names":["isArrayTypeAnnotation","isArrowFunctionExpression","isAssignmentExpression","isAwaitExpression","isBinary","isBinaryExpression","isUpdateExpression","isCallExpression","isClass","isClassExpression","isConditional","isConditionalExpression","isExportDeclaration","isExportDefaultDeclaration","isExpressionStatement","isFor","isForInStatement","isForOfStatement","isForStatement","isFunctionExpression","isIfStatement","isIndexedAccessType","isIntersectionTypeAnnotation","isLogicalExpression","isMemberExpression","isNewExpression","isNullableTypeAnnotation","isObjectPattern","isOptionalCallExpression","isOptionalMemberExpression","isReturnStatement","isSequenceExpression","isSwitchStatement","isTSArrayType","isTSAsExpression","isTSInstantiationExpression","isTSIntersectionType","isTSNonNullExpression","isTSOptionalType","isTSRestType","isTSTypeAssertion","isTSUnionType","isTaggedTemplateExpression","isThrowStatement","isTypeAnnotation","isUnaryLike","isUnionTypeAnnotation","isVariableDeclarator","isWhileStatement","isYieldExpression","PRECEDENCE","in","instanceof","isClassExtendsClause","node","parent","superClass","hasPostfixPart","object","callee","tag","NullableTypeAnnotation","FunctionTypeAnnotation","printStack","length","UpdateExpression","ObjectExpression","isFirstInContext","DoExpression","async","Binary","operator","left","parentOp","parentPos","nodeOp","nodePos","right","UnionTypeAnnotation","OptionalIndexedAccessType","objectType","TSAsExpression","TSTypeAssertion","TSUnionType","TSInferType","TSInstantiationExpression","typeParameters","BinaryExpression","SequenceExpression","test","discriminant","expression","YieldExpression","ClassExpression","UnaryLike","FunctionExpression","ArrowFunctionExpression","ConditionalExpression","OptionalMemberExpression","AssignmentExpression","LogicalExpression","Identifier","extra","parenthesized","id","name","isFollowedByBracket","computed","optional","checkParam","expressionStatement","arrowBody","exportDefault","forHead","forInHead","forOfHead","i","declaration","body","init","expressions","prefix"],"sources":["../../src/node/parentheses.ts"],"sourcesContent":["import {\n  isArrayTypeAnnotation,\n  isArrowFunctionExpression,\n  isAssignmentExpression,\n  isAwaitExpression,\n  isBinary,\n  isBinaryExpression,\n  isUpdateExpression,\n  isCallExpression,\n  isClass,\n  isClassExpression,\n  isConditional,\n  isConditionalExpression,\n  isExportDeclaration,\n  isExportDefaultDeclaration,\n  isExpressionStatement,\n  isFor,\n  isForInStatement,\n  isForOfStatement,\n  isForStatement,\n  isFunctionExpression,\n  isIfStatement,\n  isIndexedAccessType,\n  isIntersectionTypeAnnotation,\n  isLogicalExpression,\n  isMemberExpression,\n  isNewExpression,\n  isNullableTypeAnnotation,\n  isObjectPattern,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isReturnStatement,\n  isSequenceExpression,\n  isSwitchStatement,\n  isTSArrayType,\n  isTSAsExpression,\n  isTSInstantiationExpression,\n  isTSIntersectionType,\n  isTSNonNullExpression,\n  isTSOptionalType,\n  isTSRestType,\n  isTSTypeAssertion,\n  isTSUnionType,\n  isTaggedTemplateExpression,\n  isThrowStatement,\n  isTypeAnnotation,\n  isUnaryLike,\n  isUnionTypeAnnotation,\n  isVariableDeclarator,\n  isWhileStatement,\n  isYieldExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"??\": 0,\n  \"|>\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10,\n};\n\nconst enum CheckParam {\n  expressionStatement = 1 << 0,\n  arrowBody = 1 << 1,\n  exportDefault = 1 << 2,\n  forHead = 1 << 3,\n  forInHead = 1 << 4,\n  forOfHead = 1 << 5,\n}\n\nconst isClassExtendsClause = (\n  node: t.Node,\n  parent: t.Node,\n): parent is t.Class => isClass(parent, { superClass: node });\n\nconst hasPostfixPart = (node: t.Node, parent: t.Node) =>\n  ((isMemberExpression(parent) || isOptionalMemberExpression(parent)) &&\n    parent.object === node) ||\n  ((isCallExpression(parent) ||\n    isOptionalCallExpression(parent) ||\n    isNewExpression(parent)) &&\n    parent.callee === node) ||\n  (isTaggedTemplateExpression(parent) && parent.tag === node) ||\n  isTSNonNullExpression(parent);\n\nexport function NullableTypeAnnotation(\n  node: t.NullableTypeAnnotation,\n  parent: t.Node,\n): boolean {\n  return isArrayTypeAnnotation(parent);\n}\n\nexport function FunctionTypeAnnotation(\n  node: t.FunctionTypeAnnotation,\n  parent: t.Node,\n  printStack: Array<t.Node>,\n): boolean {\n  if (printStack.length < 3) return;\n\n  return (\n    // (() => A) | (() => B)\n    isUnionTypeAnnotation(parent) ||\n    // (() => A) & (() => B)\n    isIntersectionTypeAnnotation(parent) ||\n    // (() => A)[]\n    isArrayTypeAnnotation(parent) ||\n    // <T>(A: T): (T => T[]) => B => [A, B]\n    (isTypeAnnotation(parent) &&\n      // Check grandparent\n      isArrowFunctionExpression(printStack[printStack.length - 3]))\n  );\n}\n\nexport function UpdateExpression(\n  node: t.UpdateExpression,\n  parent: t.Node,\n): boolean {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\n\nexport function ObjectExpression(\n  node: t.ObjectExpression,\n  parent: t.Node,\n  printStack: Array<t.Node>,\n): boolean {\n  return isFirstInContext(\n    printStack,\n    CheckParam.expressionStatement | CheckParam.arrowBody,\n  );\n}\n\nexport function DoExpression(\n  node: t.DoExpression,\n  parent: t.Node,\n  printStack: Array<t.Node>,\n): boolean {\n  // `async do` can start an expression statement\n  return (\n    !node.async && isFirstInContext(printStack, CheckParam.expressionStatement)\n  );\n}\n\nexport function Binary(node: t.BinaryExpression, parent: t.Node): boolean {\n  if (\n    node.operator === \"**\" &&\n    isBinaryExpression(parent, { operator: \"**\" })\n  ) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if (\n    hasPostfixPart(node, parent) ||\n    isUnaryLike(parent) ||\n    isAwaitExpression(parent)\n  ) {\n    return true;\n  }\n\n  if (isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n\n    if (\n      // Logical expressions with the same precedence don't need parens.\n      (parentPos === nodePos &&\n        parent.right === node &&\n        !isLogicalExpression(parent)) ||\n      parentPos > nodePos\n    ) {\n      return true;\n    }\n  }\n}\n\nexport function UnionTypeAnnotation(\n  node: t.UnionTypeAnnotation,\n  parent: t.Node,\n): boolean {\n  return (\n    isArrayTypeAnnotation(parent) ||\n    isNullableTypeAnnotation(parent) ||\n    isIntersectionTypeAnnotation(parent) ||\n    isUnionTypeAnnotation(parent)\n  );\n}\n\nexport { UnionTypeAnnotation as IntersectionTypeAnnotation };\n\nexport function OptionalIndexedAccessType(\n  node: t.OptionalIndexedAccessType,\n  parent: t.Node,\n): boolean {\n  return isIndexedAccessType(parent, { objectType: node });\n}\n\nexport function TSAsExpression() {\n  return true;\n}\n\nexport function TSTypeAssertion() {\n  return true;\n}\n\nexport function TSUnionType(node: t.TSUnionType, parent: t.Node): boolean {\n  return (\n    isTSArrayType(parent) ||\n    isTSOptionalType(parent) ||\n    isTSIntersectionType(parent) ||\n    isTSUnionType(parent) ||\n    isTSRestType(parent)\n  );\n}\n\nexport { TSUnionType as TSIntersectionType };\n\nexport function TSInferType(node: t.TSInferType, parent: t.Node): boolean {\n  return isTSArrayType(parent) || isTSOptionalType(parent);\n}\n\nexport function TSInstantiationExpression(\n  node: t.TSInstantiationExpression,\n  parent: t.Node,\n) {\n  return (\n    (isCallExpression(parent) ||\n      isOptionalCallExpression(parent) ||\n      isNewExpression(parent) ||\n      isTSInstantiationExpression(parent)) &&\n    !!parent.typeParameters\n  );\n}\n\nexport function BinaryExpression(\n  node: t.BinaryExpression,\n  parent: t.Node,\n): boolean {\n  // let i = (1 in []);\n  // for ((1 in []);;);\n  return (\n    node.operator === \"in\" && (isVariableDeclarator(parent) || isFor(parent))\n  );\n}\n\nexport function SequenceExpression(\n  node: t.SequenceExpression,\n  parent: t.Node,\n): boolean {\n  if (\n    // Although parentheses wouldn\"t hurt around sequence\n    // expressions in the head of for loops, traditional style\n    // dictates that e.g. i++, j++ should not be wrapped with\n    // parentheses.\n    isForStatement(parent) ||\n    isThrowStatement(parent) ||\n    isReturnStatement(parent) ||\n    (isIfStatement(parent) && parent.test === node) ||\n    (isWhileStatement(parent) && parent.test === node) ||\n    (isForInStatement(parent) && parent.right === node) ||\n    (isSwitchStatement(parent) && parent.discriminant === node) ||\n    (isExpressionStatement(parent) && parent.expression === node)\n  ) {\n    return false;\n  }\n\n  // Otherwise err on the side of overparenthesization, adding\n  // explicit exceptions above if this proves overzealous.\n  return true;\n}\n\nexport function YieldExpression(\n  node: t.YieldExpression,\n  parent: t.Node,\n): boolean {\n  return (\n    isBinary(parent) ||\n    isUnaryLike(parent) ||\n    hasPostfixPart(node, parent) ||\n    (isAwaitExpression(parent) && isYieldExpression(node)) ||\n    (isConditionalExpression(parent) && node === parent.test) ||\n    isClassExtendsClause(node, parent)\n  );\n}\n\nexport { YieldExpression as AwaitExpression };\n\nexport function ClassExpression(\n  node: t.ClassExpression,\n  parent: t.Node,\n  printStack: Array<t.Node>,\n): boolean {\n  return isFirstInContext(\n    printStack,\n    CheckParam.expressionStatement | CheckParam.exportDefault,\n  );\n}\n\nexport function UnaryLike(\n  node:\n    | t.UnaryLike\n    | t.ArrowFunctionExpression\n    | t.ConditionalExpression\n    | t.AssignmentExpression,\n  parent: t.Node,\n): boolean {\n  return (\n    hasPostfixPart(node, parent) ||\n    isBinaryExpression(parent, { operator: \"**\", left: node }) ||\n    isClassExtendsClause(node, parent)\n  );\n}\n\nexport function FunctionExpression(\n  node: t.FunctionExpression,\n  parent: t.Node,\n  printStack: Array<t.Node>,\n): boolean {\n  return isFirstInContext(\n    printStack,\n    CheckParam.expressionStatement | CheckParam.exportDefault,\n  );\n}\n\nexport function ArrowFunctionExpression(\n  node: t.ArrowFunctionExpression,\n  parent: t.Node,\n): boolean {\n  return isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nexport function ConditionalExpression(\n  node:\n    | t.ConditionalExpression\n    | t.ArrowFunctionExpression\n    | t.AssignmentExpression,\n  parent?: t.Node,\n): boolean {\n  if (\n    isUnaryLike(parent) ||\n    isBinary(parent) ||\n    isConditionalExpression(parent, { test: node }) ||\n    isAwaitExpression(parent) ||\n    isTSTypeAssertion(parent) ||\n    isTSAsExpression(parent)\n  ) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nexport function OptionalMemberExpression(\n  node: t.OptionalMemberExpression,\n  parent: t.Node,\n): boolean {\n  return (\n    isCallExpression(parent, { callee: node }) ||\n    isMemberExpression(parent, { object: node })\n  );\n}\n\nexport { OptionalMemberExpression as OptionalCallExpression };\n\nexport function AssignmentExpression(\n  node: t.AssignmentExpression,\n  parent: t.Node,\n): boolean {\n  if (isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\n\nexport function LogicalExpression(\n  node: t.LogicalExpression,\n  parent: t.Node,\n): boolean {\n  switch (node.operator) {\n    case \"||\":\n      if (!isLogicalExpression(parent)) return false;\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n    case \"&&\":\n      return isLogicalExpression(parent, { operator: \"??\" });\n    case \"??\":\n      return isLogicalExpression(parent) && parent.operator !== \"??\";\n  }\n}\n\nexport function Identifier(\n  node: t.Identifier,\n  parent: t.Node,\n  printStack: Array<t.Node>,\n): boolean {\n  // 13.15.2 AssignmentExpression RS: Evaluation\n  // (fn) = function () {};\n  if (\n    node.extra?.parenthesized &&\n    isAssignmentExpression(parent, { left: node }) &&\n    (isFunctionExpression(parent.right) || isClassExpression(parent.right)) &&\n    parent.right.id == null\n  ) {\n    return true;\n  }\n  // Non-strict code allows the identifier `let`, but it cannot occur as-is in\n  // certain contexts to avoid ambiguity with contextual keyword `let`.\n  if (node.name === \"let\") {\n    // Some contexts only forbid `let [`, so check if the next token would\n    // be the left bracket of a computed member expression.\n    const isFollowedByBracket =\n      isMemberExpression(parent, {\n        object: node,\n        computed: true,\n      }) ||\n      isOptionalMemberExpression(parent, {\n        object: node,\n        computed: true,\n        optional: false,\n      });\n    return isFirstInContext(\n      printStack,\n      isFollowedByBracket\n        ? CheckParam.expressionStatement |\n            CheckParam.forHead |\n            CheckParam.forInHead |\n            CheckParam.forOfHead\n        : CheckParam.forOfHead,\n    );\n  }\n\n  // ECMAScript specifically forbids a for-of loop from starting with the\n  // token sequence `for (async of`, because it would be ambiguous with\n  // `for (async of => {};;)`, so we need to add extra parentheses.\n  //\n  // If the parent is a for-await-of loop (i.e. parent.await === true), the\n  // parentheses aren't strictly needed, but we add them anyway because\n  // some tools (including earlier Babel versions) can't parse\n  // `for await (async of [])` without them.\n  return (\n    node.name === \"async\" && isForOfStatement(parent) && node === parent.left\n  );\n}\n\n// Walk up the print stack to determine if our node can come first\n// in a particular context.\nfunction isFirstInContext(\n  printStack: Array<t.Node>,\n  checkParam: CheckParam,\n): boolean {\n  const expressionStatement = checkParam & CheckParam.expressionStatement;\n  const arrowBody = checkParam & CheckParam.arrowBody;\n  const exportDefault = checkParam & CheckParam.exportDefault;\n  const forHead = checkParam & CheckParam.forHead;\n  const forInHead = checkParam & CheckParam.forInHead;\n  const forOfHead = checkParam & CheckParam.forOfHead;\n\n  let i = printStack.length - 1;\n  if (i <= 0) return;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n  while (i >= 0) {\n    if (\n      (expressionStatement &&\n        isExpressionStatement(parent, { expression: node })) ||\n      (exportDefault &&\n        isExportDefaultDeclaration(parent, { declaration: node })) ||\n      (arrowBody && isArrowFunctionExpression(parent, { body: node })) ||\n      (forHead && isForStatement(parent, { init: node })) ||\n      (forInHead && isForInStatement(parent, { left: node })) ||\n      (forOfHead && isForOfStatement(parent, { left: node }))\n    ) {\n      return true;\n    }\n\n    if (\n      i > 0 &&\n      ((hasPostfixPart(node, parent) && !isNewExpression(parent)) ||\n        (isSequenceExpression(parent) && parent.expressions[0] === node) ||\n        (isUpdateExpression(parent) && !parent.prefix) ||\n        isConditional(parent, { test: node }) ||\n        isBinary(parent, { left: node }) ||\n        isAssignmentExpression(parent, { left: node }))\n    ) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}\n"],"mappings":"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"}
>>>>>>> main
